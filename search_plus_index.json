{"./":{"url":"./","title":"Introduction","keywords":"","body":"Hello World!😁 技术栈： 计算机基础 操作系统基础 线程与进程、死锁、并发 mmap 的使用 具有扎实的编程功底，良好的设计能力和编程习惯 网络 http tcp、ip 网络安全 面向对象、面向函数编程的区别，以及 mvvm 的使用 缓存 操作系统缓存 如何设计一个缓存系统 数据结构与算法 复杂度分析 基本数据结构 常用算法 对应的常用解决问题 工作中可用到的算法？ 代码质量与工程效率 code review 常见工程思维 代码规范 oclint、SwiftLint db技术 sqlite 数据库概念：主键、索引… iOS iOS系统相关 Runloop iOS中常用锁 Autolayout 布局 App 签名原理 GCD使用 Animation * ObjC语言 runtime 语言底层实现 第三方库源码分析 mars 使用 其他工具 CocoaPods 使用 fastlane 使用 App优化 优化思路 什么指标 如何监控 分析瓶颈 如何优化 解决问题步骤 业界怎么解决这个问题？有什么不足？怎样可以做的更好？ 解决方案能否通用化，封装成库供其他项目使用？ 有没有办法防止以后出现类似问题？能防止 或 出现问题时及时修复 总结沉淀。最好能输出文章或分享。 网络优化 网络耗时优化 稳定性优化 内存占用优化 内存泄露检测 App如何分配内存 如何实时查看 如何线上监控 Crash优化 如何收集Crash 如何上传，使用dsym 分析crash 卡顿优化 如何监控卡顿 常见卡顿原因 App模块化 Router 使用 如何 拆分 Pod 使用 CPU占用优化 如何监听 常见优化点 混合应用的开发 混合应用 常见开发思路 h5首屏秒开 调试工具 安全 如何防止被破解 如何防止重签名，被分发 常见安全优化点 网络安全 持续集成 编译流程 jenkins + fastlane 证书签名 参考： http://blog.cnbang.net/tech/3354/ "},"computer/":{"url":"computer/","title":"计算机系统","keywords":"","body":"基础 os 操作系统 负责与硬件打交道，调用硬件功能。 实现 进程、线程、虚拟内存等概念，让 一个进程正常运行，并可以实现一些功能。 浏览器、小程序 类似 Docker。提供一个运行环境，按照要求，运行一个App服务。提供UI界面，用户通过界面获取服务。 App 就是一个包含UI界面可以与用户交互的进程。 在 iOS系统，App 进程被限制，无法在后台长时间运行。具体怎么运行，需要继续探索。 一个进程如何运行？ 需要足够内存，加载可执行文件。然后执行App不同功能的对应的代码 需要足够cpu，运行功能 足够快 启动快 运行快 网络快 开发快 足够稳定 不闪退 服务稳定 内存占用： 没有内存泄露，不会持续泄露导致被系统强杀 内存 峰值 要平滑，防止某一时间使用太多内存，导致被运行缓慢 UI 相关： UI 控件 Component、Div 控件布局，位置关系 样式 stylesheet、css 与用户交互事件 Event处理 "},"computer/cpu.html":{"url":"computer/cpu.html","title":"CPU","keywords":"","body":"CPU 寄存器 CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。 但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。 寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。 参考 "},"computer/assembly_language.html":{"url":"computer/assembly_language.html","title":"汇编语言","keywords":"","body":"汇编语言 Assembly Language 简称 asm 对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。 汇编语言是二进制指令的文本形式，与指令是一一对应的关系。 每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。 链接器的任务之一是为函数调用找到匹配的函数的可执行代码的位置。 寄存器 程序计数器(被称为 PC)，在 x86-64 中用 %rip 表示，给出将要执行的下一条指令在内存中的地址。 整数寄存器包含16个命名的位置，分别存储64位的值。 指针以统一方式，对不同数据结构中的元素产生引用。 每个指针都对应一个类型 这个类型表明该指针指向的是哪一类对象。 int *ip; char **cpp; void* 为通用指针。 指针类型不是机器代码的一部分，它们是c语言提供的一种抽象，帮助程序员避免错误。 每个指针都有一个值 这个值是某个类型的对象的地址。 NULL 表示该指针没有指向任何地方。 将指针从一种类型强制转换为另一种类型，只改变它的类型，不改变它的值 指针也可以指向函数 函数指针的值是该函数既期待吗表示中的第一条指令的地址。 // 声明一个函数指针 int (*fp)(int*) int fun(int *p) { // } // 给函数指针赋值 fp = fun; 汇编指令 参考 http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html https://zh.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80 https://www.w3cschool.cn/assembly/assembly-language.html "},"computer/posix.html":{"url":"computer/posix.html","title":"POSIX","keywords":"","body":"POSIX Portable Operating System Interface Of UNIX （Portable 可移植的） POSIX 表示 可移植操作系统接口 POSIX标准 定义了操作系统应该为应用程序提供的接口标准。 维基百科： https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3 POSIX API文档: http://pubs.opengroup.org/onlinepubs/9699919799/ POSIX 定义了一系列 header，在 header 中定义了函数原型(function prototypes)、constant、common structure、宏macro，不同的操作系统会有对应的实现。 pthread.h 定义了POSIX的线程标准，定义了一套API 用于创建、操作线程 #include 参考：https://zh.wikipedia.org/wiki/POSIX%E7%BA%BF%E7%A8%8B math.h #include sys/mman.h #include mmap(void *, size_t, int, int, int, off_t) 内存管理 sys/socket.h #include // 监听 int listen(int, int) bind // client int socket(int, int, int) int connect(int, const struct sockaddr *, socklen_t) socket 编程 dirent.h #include DIR *opendir(const char *) 对目录的操作 string.h #include 对字符串操作 "},"computer/programing_paradigm.html":{"url":"computer/programing_paradigm.html","title":"编程范式","keywords":"","body":"编程范式 编程范式(programing paradigm) 范式，即 模范，典范。 指 一类典型的编程风格。例如函数式编程、面向对象编程、面向过程编程 编程范式 程序员对程序执行的看法。 例如，在面向对象编程中，程序员认为程序是一系列相互作用的对象，而在函数式编程中一个程序会被看作是一个无状态的函数计算的序列。 常见编程范式 命令式 结构化 面向对象 基于类 基于原型 自动机 面向过程 模块化、函数 非结构化 向量 声明式 函数式 数据流 响应式 面向图形编程 元编程 使用泛型 基于反射 基于组件 基于流 管道 面向代理 AOP 并行计算 自动机 Automata-based programming 自动机编程 特点： 程序运行的时间中可以清楚划分成数个自动机的步骤（step），每一个步骤即为一个程序区块，有单一的进入点，可以是一个函数或其他程序。 不同步骤的程序区块只能透过一组清楚标示的变量交换信息，这些变量称为状态（state）。程序在任二个不同时间下的差异，只有状态数值的不同，其余都相同。 参考：https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%BC%96%E7%A8%8B 有限状态机 finite-state machine FSM 有限状态机 表示有限个状态，以及这些状态直接的转移操作 参考：https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA#%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8 面向对象 对象具有的特点： 对象具有不同标识。通过内存地址区分 对象有状态。同一对象，可能处于不同状态 对象有行为。对象的状态可以，可能因为行为而变化 面向对象的3个特性：封装、继承、多态。 注意：没有重载。 基于类编程 class-based programming 在编程时，强调 对象(object) 的 类别(class)。 对象的状态和行为是有类别来定义的。 一个对象必须基于类，才能被创造出来。 一个类的不同实例(instance)唯一允许的差别只有状态。因此这种程序稳定性更好、安全性也更高 运行时，类别不允许随意需改。 基于原型的编程 prototype-based programming 是实现面向对象编程的一种方式 继承 通过赋值已经存在的原型对象来实现 对象构造 在基于类的语言中，一个实例通过类构造器来实例化对象，实例对象由类选定的行为和布局创建模型。 在基于原型的语言中，一个实例通过复制已有对象来创建新的实例。 在运行时，对象可以被自由添加属性。 "},"computer/fsm_engine.html":{"url":"computer/fsm_engine.html","title":"FSM 状态机","keywords":"","body":"FSM (Finite State Machine) 有限状态机 在一个系统内有多个状态，用于表示多个状态、状态之间切换的动作的模型 state event(action) 每当收到一个 event 后，根据当前的 state 切换到新的 state 输出 = 当前状态 + 输入 伪代码实现 FSMEngine { var curStateId var curState // -1 no change 0 state changed func receiveInput(_ dict) -> Int func start() } FSMEvent { load = 0 unload, systemCallback, pingCallback } FSMState { invalid, unloaded, loading, wifi, wwan, unreachable } State { // init func state() // receive event func onEvent(event) -> FSMState? } 状态图： event\\state invalid unloaded loading wifi wwan unreachable load loading unload unload unload unload unload unload systemCallback loaded(3) loaded(3) loaded(3) loaded(3) pingCallback loaded(3) loaded(3) loaded(3) loaded(3) 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 "},"other/":{"url":"other/","title":"网络","keywords":"","body":"other "},"other/comm.html":{"url":"other/comm.html","title":"common","keywords":"","body":"进程和线程的区别 系统级别的概念。 进程 独立的内存空间、代码、数据和其他系统资源。 对磁盘中资源的使用，无法通过加锁防止并发操作 单例、全局变量的使用要注意 iOS中的widget 是 进程， 线程 是 进程内的一个独立执行单元。 内存。一个进程内，有多个线程。多线程共享进程资源 资源。可以使用锁来处理 临界资源的访问控制 主线程 进程创建后，系统会创建一个主线程，生命周期与进程一致。主线程的退出意味着进程的终止 跨进程通信： rpc，Android中通过aidl文件来定义接口。 Android中可以通过注册 ContentProvider、调用Service、Intent 来通信 iOS中有哪些线程锁 gcd @synchronized() property中的atomic NSThread NSLock 对于 NSLock 及其子类，速度来说 NSLock pthread pthread_mutex pthread_spin_lock pthread_rwlock 系统级别的读写锁 读共享，写排他 与 dispatch_async_barrier 互斥锁、自旋锁、原子性、并发、并行 都是为了解决 对某项资源的互斥使用。一个资源 Sipnlock mutex_lock 动态库和静态库的区别 22 data race 资源竞争，保证资源的一致性 当有写操作的时候，尤其要注意。 参考： http://www.cocoachina.com/ios/20161129/18216.html 正则表达式在项目中的使用 IM App 如何确保消息可靠抵达 分两步： client1 -> server server -> client2 client1 -> server 确保发送成功 ack server收到了 想办法尽量发送成功 长短连 混用。长连断开后 使用短连发送 超时、重试机制（mars底层 10min重试） 根据外部环境变化【网络切换、前后台切换】，进行重试 server -> client2 确保接收成功，数据可靠抵达 长连通道 onPush 信令，根据 updateTime 【updateTime会在本地保存一份】，拉取最新消息 无网络到有网络，前后台切换，会通过接口优先拉取最新消息；重新check 长连，通过发送cmd，检查最新的update time 有3个通道。首先会启用 轮询机制，10 s轮询一次 每个消息都有 seq 发、收消息 都依赖于tcp的可靠性 tcp 发送的每个包都有seq，收到后 会返回 ack = seq + 1，告知对方已收到。如果没有返回ack，会触发重发机制。 但 网络上的可靠性 不等同于业务层的可靠性。网络层之上的应用层也可能会失败，如何确保应用层传成功？ 方案1. 存入本地db认为应用层成功。成功后，像server 发送一个 ack 确认，否则 server 会重发 方案2.每个message 都有 seq。 db中保存 lastReceivedSeqId。如果接收到新消息后，发现seq 不连续，就认为丢失了数据，需要重新fetch 方案3.本地保存最新的updateTime(server返回的)，获取到新消息，并且存入 db 后，更新本地的updateTime。【udpateTime实际是最新一条数据的时间 】 property 的默认修饰符 对象。(atomic, strong, readwrite) 基本数据类型。 (atomic, assign, readwrite) KVO原理 使用： - (void)init {} [obj addObserver:self forKeyPath:@\"obj_property_name\" options:NSKeyValueChangeNewKey context:nil]; } - (void)dealloc { [obj removeObserver:self forKeyPath:@\"obj_property_name\"]; } - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { // } 具体原理 kvo 基于runtime 实现 当Person对象的某个 property 被观察后，会重新生成一个setter 在复制的前后调用 willChangeValueForKey: 和 didChangeValueForKey: ，从而 observeValueForKey:ofObject:change:context: 也会被调用 实际Person对象，会生成一个Person的子类 NSKVONotifying_Person ，然后Person对象的isa指针指向 NSKVONotifying_Person。 NSKVONotifying_Person 的set重写为： - (void)setName:(NSString *)name { [self willChangeValueForKey: @\"name\"]; [super setName: name]; // 调用父类的setName，即使我们重写了setName 也会正常调用 [self didChangeValueForKey: @\"name\"]; } 参考：https://zhuanlan.zhihu.com/p/34273366 "},"other/tcp.html":{"url":"other/tcp.html","title":"tcp","keywords":"","body":"TCP ask 1. 3次 和 4次 握手 2. 如何保证传输 是可靠的 3. 如何 尽可能快的传输数据？ TCP是面向连接的、可靠的协议。 面向连接指在交换数据之前，需要首先建立一个连接。 面像字节流的协议指两端独立选择自己的读和写大小，并不关注对方一次读或写的数据大小。 双工服务数据可向两个方向流动，两个方向相互独立。 知识点 连接管理 超时与重试机制 数据流与窗口管理 拥塞控制 保活机制 如何保证可靠 连接管理 （创建连接和关闭连接），创建连接后才会发送数据 通过 确认应答ack 确保数据已到达 通过 验和checkSum 确保数据没有损坏 通过 序列号 确保数据的顺序 （重发控制）丢包后的重发机制 通过窗口控制，实现高速传输，减少延迟 1. 连接管理 详细看连接管理的知识： https://blog.csdn.net/kuangdacaikuang/article/details/53386544 建立连接 3次handshake 客户端与服务端通过SYN报文段交换彼此的seq。 结束连接 4次handshake 2. 超时与重试机制 （可以主动重试，1 1 1 5 10 类似这种） 发送数据后，一直没有等到ack，等待时间超过了设定时间。 * 重发超时 的计算。通过往返时间和偏差 计算所得。一般为6s。 * 重发达到一定次数后，如果仍然没有结果，会关闭连接。 在iOS测试，tcp重试机制：一共试11次，前6次间隔1s，最后间隔 32s，共耗时67s。67s后，超时。前10s有6次重试。 时间间隔：1、1、1、1、1、2、4、8、16、32 重试的关键是 根据给定连接的RTT设置RTO 若 RTO 设置太短，可能在ACK回来之前，开始重传 若 RTO 设置太长，则可能会延迟重传，降低网路的利用率 根据每次ACK的时间，可以确定 RTT。RTT 是会动态变化的。 平滑的RTT估计值 使用n个样本，通过求平均值来计算。每当有新的值，RTT的估计值就会有更新。 3. 数据流与窗口管理 TCP的流量控制 用于调节 发送速率。基于ACK数据包中通告窗口大小字段来实现。这种方式提供了明确的接收方返回的信息，避免接收方缓存溢出。 4. 拥塞控制（为了 减少失败率，提升发送速度） 当认为网络即将进入拥塞状态时，减缓TCP的传输。难点是：如何判断拥塞？如何减缓TCP传输？何时恢复速度？ 如何判断拥塞？ 丢包率 被用来判断是否发生拥塞 减缓 5. 保活机制（心跳包 keepalive时间 ） NAT超时 和 网络状态变化 都有可能导致 TCP连接断开。 大部分NAT路由器包含超时机制。大部分移动无线网络运营商都在链路一段时间没有数据通讯时，会淘汰 NAT 表中的对应项，造成链路中断。国内的超时时间是 5分钟。 mars中，每隔4.5 min会发送一次智能心跳。时间 会随着网络的好坏、数据发送频率调整。 会记录心跳失败的次数，当次数增加时会增缩短心跳时间。 其他时间会做一次心跳： 切到前台 网络变化 更多：https://mp.weixin.qq.com/s/ghnmC8709DvnhieQhkLJpA? 术语 SYN 在建立连接时，用于同步序列号 FIN 该保温袋的发送方已经结束向对方发送数据 ACK 确认 RST 重置连接 ISN(c) 客户端初始序列号 ISN(s) 服务器端初始序列号 RTT RTO 重试时间 tcp头部格式 参考 https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286458&idx=1&sn=320f690faa4f97f7a49a291d4de174a9&chksm=8334c3b8b4434aae904b6d590027b100283ef175938610805dd33ca53f004bd3c56040b11fa6#rd "},"other/mars.html":{"url":"other/mars.html","title":"mars","keywords":"","body":" 目录 {:toc} mars 优点： 跨平台，只需维护一套代码 提供长连、短连 两种网络通道 动态下发ip，就近接入 贴合移动端的平台特性：前后台切换、网络切换 会检测连接是否连通 智能心跳 高效的日志组件 xlog ask 1. mars 相比 tcp 的优化点 2. mars 相比 websocket 的优化点 弱网优化 连接优化 发消息优化 智能心跳优化 超时重传优化 多IP优化 弱网优化 弱网情况下 上下行 3k/2k mars 明显优于 websocket，websocket 基本收不到消息 弱网情况下 上下行 8k 断网重连后，明显优于websocket 快 3s 左右 连接优化 iOS 的 connect 超时重传如下图所示。超时间隔依次为（1，1，1，1，1，2，4，8，16，32），总共是67s。 这就意味着，在不能立刻确认失败（例如 unreachable 等）的情况下，需要67秒的时间，才能获得结果。如果真相并不是用户的网络不可用，而是某台服务器故障、繁忙、网络不稳定等因素，那75秒的时间只能尝试1个 IP&Port 资源，对于大多数移动应用而言，是不可接受的。我们需要更积极的超时重传机制！！！ 我们不能修改TCP的超时机制。在应用层超时重传，典型做法就是提前结束 connect 的阻塞调用，使用新的 IP&Port 资源进行 connect 重试。 更多详细：https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286458&idx=1&sn=320f690faa4f97f7a49a291d4de174a9&chksm=8334c3b8b4434aae904b6d590027b100283ef175938610805dd33ca53f004bd3c56040b11fa6#rd 发消息优化 长短连 两种模式自动切换 发的数据多的时候，长连可能会慢，会切换到 短连发送 弱网情况下，长连可能已经断了，此时 通过短连发送效果会更好 智能心跳优化 根据 前后台状态 和 心跳失败的次数 自动判断 心跳的时间 多IP 自动切换IP，提升连接速度 超时重传 在TCP的超时重传的基础上，在应用层有自己的超时重传逻辑，尽可能提高成功率。 TCP 层的超时重传机制可以发现，当发生超时重传时，重传的间隔以“指数退避”的规律急剧上升。在 Android 系统中，直到16分钟，TCP 才确认失败；在 iOS 系统中，直到1分半到3分半之间，TCP 才确认失败。这些数值在大部分应用中都是不为“用户体验”所接受的。用户体验太差。 设计思路： 减少等待时间，增加重试次数 切换链路(ip/port)，重新建立连接 优化1： 根据网络的状况：优质、正常、差，分别设置超时时间。优质的网络，超时时间设置短（预期网络恢复快） 超时 在 Mars 中有四个超时概念，分别为首包超时、包包超时、读写超时、任务超时。首包超时为从请求发出去到收到第一个包最大等待时长，读写超时则是单次请求从发送请求到收到完整回包的最大等待时长，计算公式分别为： 首包超时 = 发包大小/最低网速+服务器约定最大耗时+并发数*常量； 包包超时 = 常量； 读写超时 = 首包超时+最大回包大小/最低网速； 任务超时 = (读写超时 + 常量) * 重试次数。 在mars的读写超时计算中，有一个最大回包大小，预估值为64k。 mars 不建议传输大数据，一般用来传输信令 项目中使用 一、增加了加密、压缩功能 修改以下文件，增加RSA、AES和ZLIB相关函数 \\merc\\client\\mars\\mars\\openssl\\export_include\\aes_crypt.h \\merc\\client\\mars\\mars\\openssl\\export\\aes_crypt.c \\merc\\client\\mars\\mars\\openssl\\export_include\\rsa_crypt.h \\merc\\client\\mars\\mars\\openssl\\export\\crypto\\rsa_crypt.cpp 二、增加了用户login，session 管理逻辑 更新以下文件 \\merc\\client\\mars\\mars\\stn\\stn_logic.h: 增加SetParameter,OpenSession,CloseSession,GetSessionId,GetCurrentLonglinkIp,ClearCmds所有接口定义； \\merc\\client\\mars\\mars\\stn\\stn_logic.cc: 增加OnOpenSession回调实现 \\merc\\client\\mars\\mars\\stn\\proto\\longlink_packer.cc: 长连封包格式及核心业务扩展实现 \\merc\\client\\mars\\mars\\libraries\\mars_android_sdk\\jni\\longlink_packer.cc: 安卓编译需要 \\merc\\client\\mars\\mars\\stn\\src\\net_core.h: 主要配合实现 ClearCmds, GetCurrentLonglinkIp 接口 \\merc\\client\\mars\\mars\\stn\\src\\net_core.cc: 同上 \\merc\\client\\mars\\mars\\stn\\src\\longlink_task_manager.h: 同上 \\merc\\client\\mars\\mars\\stn\\src\\longlink_task_manager.cc: 同上 \\merc\\client\\mars\\mars\\stn\\src\\longlink.cc: 优化session_id为0不发送心跳数据 三、优化 切换账户，可以服用之前的tcp连接 重新做login操作即可 客户端编译脚本: \\merc\\client\\mars\\mars\\libraries\\build_android.py \\merc\\client\\mars\\mars\\libraries\\build_apple.py \\merc\\client\\mars\\mars\\libraries\\build_for_win32.py "},"other/websocket.html":{"url":"other/websocket.html","title":"WebSocket","keywords":"","body":"WebSocket 介绍 WebSocket 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。一开始的握手需要借助HTTP请求完成。 开发 WebSocket 的目的是为了 替代轮询，使网页有即时通讯的能力 轮询的缺点： 会导致不必要的请求，浪费资源。即时没有消息，也需要轮询 每次一轮询都有 请求和应答，header 带的消息比较多，也会浪费资源。 如果有消息，没法即时获取。 WebSocket 特点： 与 http 一样，都属于应用层协议 在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 Websocket使用ws或wss的统一资源标志符，类似于HTTPS，其中wss表示在TLS之上的Websocket。如： ws://example.com/wsapi wss://secure.example.com/ Websocket使用和 HTTP 相同的 TCP 端口，可以绕过大多数防火墙的限制。默认情况下，Websocket协议使用80端口；运行在TLS之上时，默认使用443端口。 握手 WebSocket 是独立的、创建在 TCP 上的协议。 Websocket 通过 HTTP/1.1 协议的101状态码进行握手。 握手过程： Client GET / HTTP/1.1 Upgrade: websocket Connection: Upgrade Host: example.com Origin: http://example.com Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ== Sec-WebSocket-Version: 13 Server HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s= Sec-WebSocket-Location: ws://example.com/ 发送数据 WebSocket 通过数据帧(Data Frame)的方式发送数据。 客户端发送的数据帧都要经过掩码处理，服务端发送的所有数据帧都不能经过掩码处理。否则对方需要发送关闭帧。 一个帧包含一个帧类型的标识码，一个负载长度，和负载。负载包括扩展内容和应用内容。 RFC6455中定义的帧类型如下所示： 1）Opcode == 0 继续： 表示此帧是一个继续帧，需要拼接在上一个收到的帧之后，来组成一个完整的消息。由于这种解析特性，非控制帧的发送和接收必须是相同的顺序。 2）Opcode == 1 文本帧。 3）Opcode == 2 二进制帧。 5）Opcode == 8 关闭连接（控制帧）： 此帧可能会包含内容，以表示关闭连接的原因。通信的某一方发送此帧来关闭WebSocket连接，收到此帧的一方如果之前没有发送此帧，则需要发送一个同样的关闭帧以确认关闭。如果双方同时发送此帧，则双方都需要发送回应的关闭帧。理想情况服务端在确认WebSocket连接关闭后，关闭相应的TCP连接，而客户端需要等待服务端关闭此TCP连接，但客户端在某些情况下也可以关闭TCP连接。 6）Opcode == 9 Ping： 类似于心跳，一方收到Ping，应当立即发送Pong作为响应。 7）Opcode == 10 Pong： 如果通信一方并没有发送Ping，但是收到了Pong，并不要求它返回任何信息。Pong帧的内容应当和收到的Ping相同。可能会出现一方收到很多的Ping，但是只需要响应最近的那一次就可以了。 参考 https://tools.ietf.org/html/rfc6455 http://www.ruanyifeng.com/blog/2017/05/websocket.html http://www.52im.net/thread-1266-1-1.html http://www.52im.net/thread-1273-1-1.html "},"other/http.html":{"url":"other/http.html","title":"http","keywords":"","body":"http Request 格式 [Request Line] [CRLF] general-header request-header entity-header[CRLF] [CRLF] message-body POST http://www.example.com HTTP/1.1 Content-Type: application/x-www-form-urlencoded;charset=utf-8 accept-language: zh-CN title=test&sub%5B%5D=1&sub%5B%5D=2&sub%5B%5D=3 Response 格式： [Status Line] [CRLF] general-header response-header entity-header[CRLF] [CRLF] message-body 示例： HTTP/1.1 200 OK Content-Length: 3059 Server: GWS/2.0 Date: Sat, 11 Jan 2003 02:44:04 GMT Content-Type: text/html Cache-control: private Set-Cookie: PREF=ID=73d4aef52e57bae9:TM=1042253044:LM=1042253044:S=SMCc_HRPCQiqy X9j; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.com Connection: keep-alive ... Status Code 状态码 1xx 消息——请求已被服务器接收，继续处理 Request received, continuing process 2xx 成功——请求已成功被服务器接收、理解、并接受 3xx 重定向——需要后续操作才能完成这一请求 Further action must be taken in order to complete the request 4xx 请求错误——请求含有词法错误或者无法被执行 Client Error - The request contains bad syntax or cannot be fulfilled 5xx 服务器错误——服务器在处理某个正确请求时发生错误 The server failed to fulfill an apparently valid request 100 Continue 101 Switching Protocols 服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。WebSocket 使用 200 OK 201 Created 202 Accepted 301 Moved Permanently **重定向**资源被永久移动到了新位置 304 Not Modified 400 Bad Request 401 403 Forbidden 服务器已接收到请求，但拒绝执行 404 Not found 500 Internal Server Error 501 Not Implemented 502 Bad Gateway 参考：https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#1xx%E6%B6%88%E6%81%AF header General Header Upgrade 提供一个机制，可以切换 protocol。 client 通过 Upgrade 列出希望使用的 ptorocol server 返回新选定的 protocol， 返回码为 101 Content-Type Content-Type: application/x-www-form-urlencoded Content-Type: application/json HSTS Strict-Transport-Security: max-age=0 HTTP Strict Transport Security（通常简称为HSTS）是一个安全功能，它告诉浏览器只能通过HTTPS访问当前资源，而不是HTTP。 max-age= 设置在浏览器收到这个请求后的秒的时间内凡是访问这个域名下的请求都使用HTTPS请求。 Request Header Host: www.w3.org 必须的参数。 User-Agent: CERN-LineMode/2.15 libwww/2.17b3 Location: http://www.w3.org/pub/WWW/People.html 重定向 If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT 假如请求的资源在该日期之后没有modify，则返回 304 ，不会反回 entity Response Header Cache-Control Cache-Control: public, max-age=0 Entity Entity Header Allow: GET, HEAD, PUT 一般，返回 405(Method Not Allowed) 时，会返回 Allow Header，列出该 Request-URI 支持的 methods Content-Encoding Content-Language Content-Length Content-Location Content-MD5 Content-Range Content-Type Expires Last-Modified extension-header Entity Body HTTP2.0和HTTP1.X相比的新特性 tcp连接 复用 header 压缩 参考 http: https://tools.ietf.org/html/rfc2616#section-5 "},"other/https.html":{"url":"other/https.html","title":"https","keywords":"","body":"https 解决的问题 1可能窃听 http 的报文是明文，会被直接看到。https 会做加密，防止被看到。 2服务器的认证问题 无法确认发送到的服务器就是真正的服务器。https 通过校验 服务器的证书来确认服务器的身份。 3防止被篡改 请求或响应在传输图中可能被篡改。https通过数据加密、解密，防止数据的篡改。通过 数据MAC校验 数据的完整性。 基本流程 参考： tls文章 https://juejin.im/entry/5a644a61f265da3e4c07e334 https 证书 https 证书内包括： 签发机构 申请者 域名 domain 公钥 pub_server 证书有效期 摘要 参考 https:https://tools.ietf.org/html/rfc2818.html https://segmentfault.com/a/1190000015155372 详细流程：https://www.jianshu.com/p/b0b6b88fe9fe 校验域名 校验证书 "},"other/socket.html":{"url":"other/socket.html","title":"socket","keywords":"","body":"api client端： // create socket int fd = socket(AF_INET, SOCK_STREAM , 0); BOOL success = (fd!=-1); int err; struct sockaddr_in addr; if (success) { // create success NSLog(@\"socket success\"); memset(&addr, 0, sizeof(addr)); addr.sin_len=sizeof(addr); addr.sin_family=AF_INET; addr.sin_addr.s_addr=INADDR_ANY; // 绑定客户端的 ip 与 一个端口 err = bind(fd, (const struct sockaddr *)&addr, sizeof(addr)); success=(err==0); } if (success) { struct sockaddr_in peeraddr; memset(&peeraddr, 0, sizeof(peeraddr)); peeraddr.sin_len=sizeof(peeraddr); peeraddr.sin_family=AF_INET; peeraddr.sin_port=htons(1024); peeraddr.sin_addr.s_addr=inet_addr(\"172.16.10.120\"); // 服务器地址 socklen_t addrLen; addrLen =sizeof(peeraddr); // 与服务器连接，3次握手 err = connect(fd, (struct sockaddr *)&peeraddr, addrLen); success = (err==0); if (success) { err = getsockname(fd, (struct sockaddr *)&addr, &addrLen); success = (err==0); if (success) { NSLog(@\"connect success,local address:%s,port:%d\",inet_ntoa(addr.sin_addr),ntohs(addr.sin_port)); char buf[1024]; do { printf(\"input message:\"); scanf(\"%s\",buf); // 发送数据 send(fd, buf, 1024, 0); } while (strcmp(buf, \"exit\")!=0); } } else{ NSLog(@\"connect failed\"); } } server端 int err; int fd = socket(AF_INET, SOCK_STREAM , 0); BOOL success=(fd!=-1); if (success) { NSLog(@\"socket success\"); struct sockaddr_in addr; memset(&addr, 0, sizeof(addr)); addr.sin_len=sizeof(addr); addr.sin_family=AF_INET; addr.sin_port=htons(1024); addr.sin_addr.s_addr=INADDR_ANY; err = bind(fd, (const struct sockaddr *)&addr, sizeof(addr)); success=(err==0); } if (success) { NSLog(@\"bind(绑定) success\"); err = listen(fd, 5);//开始监听 success=(err==0); } if (success) { NSLog(@\"listen success\"); while (true) { struct sockaddr_in peeraddr; int peerfd; socklen_t addrLen; addrLen = sizeof(peeraddr); NSLog(@\"prepare accept\"); peerfd = accept(fd, (struct sockaddr *)&peeraddr, &addrLen); success = (peerfd!=-1); if (success) { NSLog(@\"accept success,remote address:%s,port:%d\",inet_ntoa(peeraddr.sin_addr),ntohs(peeraddr.sin_port)); char buf[1024]; ssize_t count; size_t len=sizeof(buf); do { count=recv(peerfd, buf, len, 0); NSString* str = [NSString stringWithCString:buf encoding:NSUTF8StringEncoding]; NSLog(@\"%@\",str); } while (strcmp(buf, \"exit\")!=0); } close(peerfd); } } "},"other/tls.html":{"url":"other/tls.html","title":"tls","keywords":"","body":"Record Protocol The TLS Record Protocol is a layered protocol. At each layer, messages may include fields for length, description, and content. The Record Protocol takes messages to be transmitted, fragments the data into manageable blocks, optionally compresses the data, applies a MAC, encrypts, and transmits the result. Received data is decrypted, verified, decompressed, reassembled, and then delivered to higher-level clients. TLS Connection 传递数据，需要以下参数： connectinon end。是 client 或 server RF algorithm。用于计算 master_key bulk encryption algorithm。用于加密数据 MAC algorithm。用于计算 message 的 MAC 值。 compression algorithm。 压缩算法 master secret。48 bytes secret client random。32 bytes server random。3 random Handsahke Protocol 1ClientHello ClientHello 发送的数据包括： client_version (tls版本) random; // ranome struct session_id (可能为空, 用于标识当前的connection) cipher_suites （client 支持的加密算法 list） compression_methods （client 支持的压缩算法） struct { uint32 gmt_unix_time; // current time opaque random_bytes[28]; } Random; 32 bytes 2ServerHello Server 当收到了 ClientHello 后，向 client 发送 ServerHello ServerHello 包含数据： server_verison () random (由 server 生成的 random struct) session_id (用于标识 connection，如果 ClientHello 没有传，则会生成一个新的) cipher_suite (由 server 选中的加密算法) compression_method (由 server 选中的压缩算法) 3Server Certificate 向 client 发送证书和公钥 此处发送的是从权威机构申请的CA证书。 证书中包含服务器公钥、服务器域名，然后证书通过CA私钥签名。 client 在收到证书后，会使用CA的公钥验证签名，以此来验证 服务器的身份、公钥和域名是否真实。 4Certificate Request 向 client 请求证书 5Server Hello Done 当 ServerHello 和 相关信息发送完后，server 会发送 ServerHelloDone。之后会等待 client 的响应。 6Client Certificate 当 client 接收到 ServerHelloDone 后。如果 server 要求证书，client 会向 server 发送 ClientCertificate 7Client Key Exchange Message 由 client 发送。 client 随机生成一个48字节的 pre_master_key，然后通过 server-rsa-public-key 加密，发送给 server。 8Finished 此时双方可以根据同样的算法计算出 master_key 。master_key 为固定长度 48 bytes master_secret = PRF(pre_master_secret, \"master secret\", ClientHello.random + ServerHello.random) [0..47]; 相互发送 Finished message。 Finished message 是第一个使用协商好的 algorithms, master key 来加密的消息。 如果一方已经发送了 Finished，并且接收、验证了对方的 Finished message，则就可以发送 Application Data 了 Application data messages are carried by the record layer and are fragmented, compressed, and encrypted based on the current connection state. The messages are treated as transparent data to the record layer. 其他 CA认证 CA Certificate Authority，负责发放和管理数字证书的权威机构。 CA发放的数字证书，证明证书中列出的用户机构合法拥有证书中列出的公钥。 MAC Message Authentication Code 消息识别码 通过 MAC algorithm 计算 message 生成 MAC，使用 MAC 来校验消息的完整性。 HMAC Hash-based Message Authentication Code 哈希消息认证码 HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。 HMAC（K，M） 参考： tls:https://www.ietf.org/rfc/rfc5246.txt https://juejin.im/entry/5a644a61f265da3e4c07e334 "},"other/xlog.html":{"url":"other/xlog.html","title":"xlog","keywords":"","body":"xlog xlog整体流程： 生成一条log -> 格式化数据 -> 压缩 -> 加密 -> 写入内存 (-> 可能会写入mmap文件) -> 超过1/3大小后，写入本地文件 xlog 高效的日志系统 收集日志 不卡顿，会压缩 自动上传，指定某个用户的日志上传 更多：https://mp.weixin.qq.com/s/PnICVDyVuMSyvpvTrdEpSQ? "},"other/rejex.html":{"url":"other/rejex.html","title":"正则表达式","keywords":"","body":"正则表达式 Regular Expression 用途： 字符串搜索 字符串替换 限定符 ^ 匹配字符串的开始位置 $ 匹配字符串的结束位置 * 匹配前面的子表达式0次或多次 等价于 {0,} + 匹配前面的子表达式1次或多次 等价于 {1,} ？ 匹配前面的子表达式0次或1次 等价于 {0,1} {n} 匹配确定的n次 {n,} 至少n次 {n,m} n到m次 [xyz] 匹配包含的任一个字符 [^xyz] 匹配除xyz外的任一个字符 [a-z] [^a-z] 匹配a-z之外的任一字符 参考：https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F 常用的正则 ^[0-9]*$ 字符串只包括0-9的数字 包括空字符串 ^[0-9]+$ 字符串只包括0-9的数字 不包括空字符串 ^[A-Za-z]*$ 是否为大小写字母，包括空字符串 \\\\d 是否为数字 例如 11.2 3.14 444 Swift中正则的使用 fileprivate func isPureNumber(_ string: String) -> Bool { return textRegex(content: string, pattern: \"^[0-9]*$\") } fileprivate func isPureLetter(_ string: String) -> Bool { return textRegex(content: string, pattern: \"^[A-Za-z]*$\") } fileprivate func isPureSymbol(_ string: String) -> Bool { // let regex: NSPredicate = NSPredicate(format: \"SELF MATCHES %@\", \"^[~\\\\^{}[]()<><>_\\\\$@#%&/\\\\|=-+*`‘”;:\\\\.,!?]*$\") return !hasLetter(string) && !hasNumber(string) } fileprivate func isNumberAndLetterAndSymbol(_ string: String) -> Bool { return hasNumber(string) && hasLetter(string) && !isNumberAndLetter(string) } private func isNumberAndLetter(_ string: String) -> Bool { let regex: NSPredicate = NSPredicate(format: \"SELF MATCHES %@\", \"^[0-9A-Za-z]*$\") return regex.evaluate(with: string) } private func hasNumber(_ string: String) -> Bool { return textRegex(content: string, pattern: \"[0-9]\") } private func hasLetter(_ string: String) -> Bool { return textRegex(content: string, pattern: \"[A-Za-z]\") } private func textRegex(content: String, pattern: String) -> Bool{ do { // 定义规则 // let pattern = \"ben\" // 创建正则表达式对象 let regex = try NSRegularExpression(pattern: pattern, options: NSRegularExpression.Options.caseInsensitive) // 开始匹配 let result = regex.matches(in: content, options: NSRegularExpression.MatchingOptions(rawValue: 0), range: NSMakeRange(0, content.count)) // print(result.count) if result.count > 0 { return true } } catch { print(error) } return false } "},"algorithm/":{"url":"algorithm/","title":"算法","keywords":"","body":"数据结构与算法 Bad programmers worry about the code. Good programmers worry about data structures and their relationship 特定数据结构是对特定场景的抽象 数据结构是为算法服务的，具体选择哪种存储方法，与期望支持的操作有关系。 常见用途： 提高效率。例如 排序、查找的不同算法，尽量降低时间复杂度，提高效率 为了解决某一领域的问题。例如图 使用某种算法可以简化计算方式，一般通过 数学来简化或转化为另一个问题 算法是抽象出的模型，学习完后需要应用于具体的编程实例中。 学习的过程： 学习不同算法和数据类型，各自的优缺点和实际应用场景 通过阅读源码学习具体算法的使用 在编程中可以熟练使用不同算法 CPU资源是有限的，任务的处理速度与线程个数并不是线性相关。相反，过多的线程反而会导致CPU频繁切换，处理性能下降。线程池的大小一般要综合考虑处理任务的特点和硬件环境，来事先设置。 "},"algorithm/basic/":{"url":"algorithm/basic/","title":"基础","keywords":"","body":"数据抽象 数据类型指一组值和一组对这些值的操作的集合。 抽象数据类型ADT是一种能够对使用者隐藏数据表示的数据类型。使用的时候，只关注API描述的操作，而不关系数据的表示。 在实现抽象数据类型的时候，我们需要关注数据本身，并实现对该数据的各种操作。 以适用于各种用途的API形式准确的定义问题 用API的实现描述算法和数据结构 "},"algorithm/basic/recursion.html":{"url":"algorithm/basic/recursion.html","title":"递归","keywords":"","body":"递归 递归是一种广泛使用的编程技巧。 DFS、前中后序二叉树遍历 可用 递归实现。 如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了 编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。 递归需要满足3个条件： 一个问题的解可以分解几个子问题的解（子问题就是数据规模更小的问题） 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样 存在递归终止条件。终止条件，用于终止无限循环 如何编写递归代码？ 找到递归公式 找到终止条件 所有的递归问题 都可用递归公式表示。把递归公式转化为代码。 注意问题 递归代码要警惕堆栈溢出 递归代码要警惕重复计算 参考 https://time.geekbang.org/column/article/41440 "},"algorithm/basic/stack.html":{"url":"algorithm/basic/stack.html","title":"栈","keywords":"","body":"栈是一种操作受限的线性表。当某个数据集合只涉及某一端插入和删除数据，并且满足先进后出的特性，我们就可以用 栈 这种数据结构。 public struct Stack { fileprivate var array = [T]() public var count: Int { return array.count } public var isEmpty: Bool { return array.isEmpty } public mutating func push(_ element: T) { array.append(element) } public mutating func pop() -> T? { return array.popLast() } public var top: T? { return array.last } } class Stack1 { var head: Node1? func push(_ element: Element) { if head == nil { head = Node1(element) return } let node = Node1(element) node.next = head head = node } func pop() -> Element? { let node = head head = head?.next return node?.value } } class Node1 { var value: Element var next: Node1? init(_ v: Element) { value = v } } 具体实例 浏览器的前进、后退操作 使用两个栈记录页面 // 打开了 a b c 三个页面 stack1 push a b c stack2 为空 // 后退到a页面 stack1 pop c、b，此时stack1数据为 a stack2 push c、b 此时stack2数据为 c、b // 前进到b页面 stack1：a、b stack2：c //打开一个新页面d stack1：a、b、d stack2 清空 栈在括号中匹配的应用 检测一个表达式中 {} [] () 是否匹配 原理：在一个stack中存储括号，遇到左括号则入栈，遇到右括号 则从stack pop一个左括号，看是否匹配。有一个不匹配，则表达式有问题。 栈在表达式求值中的应用 算术表达式 3 + 9 × 2 - 5 + 6 × 3 使用两个栈，stack1 存储数字，stack2 存储运算符。每次遇到运算符n后，从stack2中pop运算符m作比较，如果m优先级更高，则从stack1取数字先进行m的运算，结果保存到stack1中，之后从stack2 pop一个新的运算符 以此类推 stack1 3、9 stack2 + stack1 3、9、2 stack2 +、 × // 遇到运算符 -， × 优先级更高，先进行 × stack1 3、18 stack2 + // 遇到 -， 先进行 + stack1 21 stack2 stack1 21、5 stack2 - // 遇到 +，先进行 - stack1 16 stack2 stack1 16、6 stack2 + stack1 16、6、3 stack2 +、 × stack1 16、18 stack2 + stack1 34 stack2 // result = 34 "},"algorithm/basic/queue.html":{"url":"algorithm/basic/queue.html","title":"队列","keywords":"","body":"队列是一种操作受限的线性表。支持enqueue和dequeue操作。 使用数组实现 public struct Queue { fileprivate var array = [T?]() fileprivate var head = 0 public var isEmpty: Bool { return count == 0 } public var count: Int { return array.count - head } public mutating func enqueue(_ element: T) { array.append(element) } public mutating func dequeue() -> T? { guard head 50 && percentage > 0.25 { array.removeFirst(head) head = 0 } return element } public var front: T? { if isEmpty { return nil } else { return array[head] } } } 使用链表实现 public struct Queue { fileprivate var head: Node? fileprivate var tail: Node? public mutating func enqueue(_ element: T) { let node = Node(element) if head == nil { head = node } if let tail = tail { tail.next = node } tail = node } public mutating func dequeue() -> T? { guard let head = head else { return nil } let node = head self.head = head.next return node.value } } class Node { var value: T var next: Node? init(_ v: T) { value = v } } 循环队列 环形数据结构不再需要数据搬移 public class CircularQueue { // 数组：items，数组大小：n private String[] items; private int n = 0; // head 表示队头下标，tail 表示队尾下标 private int head = 0; private int tail = 0; // 申请一个大小为 capacity 的数组 public CircularQueue(int capacity) { items = new String[capacity]; n = capacity; } // 入队 public boolean enqueue(String item) { // 队列满了 if ((tail + 1) % n == head) return false; items[tail] = item; tail = (tail + 1) % n; return true; } // 出队 public String dequeue() { // 如果 head == tail 表示队列为空 if (head == tail) return null; String ret = items[head]; head = (head + 1) % n; return ret; } } 阻塞队列 在队列的基础上增加了阻塞操作。如果队列为空，从队头取数据会被阻塞；如果队列满了，从队尾插入数据会被阻塞，知道队列中有空闲位置可以再插入数据然后才返回。 待学习： linux中使用的环形队列：https://www.cnblogs.com/Anker/p/3481373.html Disruptor队列介绍：https://tech.meituan.com/disruptor.html "},"algorithm/basic/b-tree.html":{"url":"algorithm/basic/b-tree.html","title":"B树","keywords":"","body":"B树 B树即为加快树状结构访问速度而设计的数据结构，常被应用在数据库和文件系统上 "},"algorithm/basic/DynamicProgramming.html":{"url":"algorithm/basic/DynamicProgramming.html","title":"动态规划","keywords":"","body":"动态规划 DP 动态规划的过程： 初始状态 -> 决策1 -> 决策2 -> 。。 -> 决策n -> 结束状态 每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。 与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。 使用动态规划求解问题，最重要的就是确定动态规划三要素： 问题的阶段 每个阶段的状态 从前一个阶段转化到后一个阶段之间的递推关系 整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态 案例 https://segmentfault.com/a/1190000004498566#articleHeader4 参考 https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html https://segmentfault.com/a/1190000004498566 https://blog.csdn.net/u013309870/article/details/75193592 "},"algorithm/basic/graph.html":{"url":"algorithm/basic/graph.html","title":"图","keywords":"","body":"图 Graph 非线性表数据结构 顶点 vertex 边 edge 度 degree 顶点的度 （与顶点相连接的边的条数） 有向图(边有方向) 无向图(边没有方向) 稀疏图 顶点多，关系相对较少 （例如 微信中的社交关系） 入度(in-degree) 和 出度(out-degree) 有向图中，顶点的入度 表示 有多少边指向这个点 有向图中，顶点的出度 表示 有多少边以这个点为起点指向其他顶点 对应到微博的例子，入度就表示有多少粉丝，出度就表示关注了多少人。 带权图 weighted graph 在带权图中 每个边都有一个权重 图的存储 使用领接矩阵存储（二维数组） 特点： 简单，直观 基于数组，获取两个点的关系很高效 浪费空间 领接表存储 每个顶点都对应一个链表，链表中存储这个点指向的其他点(微博中 我关注了谁)。 逆领接表 每个顶点都对应一个链表，链表中存储指向这个点的其他点(微博中的粉丝，谁关注了我)。 特点： 存储节省空间 计算时耗费时间(例如获取两个点的关系) img](/asserts/img/03/94/039bc254b97bd11670cdc4bf2a8e1394.jpg) 优化：存储顶点时，可以把链表替换成平很二叉树、跳表、红黑书，提升查找速度 "},"algorithm/basic/graph-bfs-dfs.html":{"url":"algorithm/basic/graph-bfs-dfs.html","title":"图的BFS、DFS","keywords":"","body":"图的BFS 和 DFS 图的定义 public class Graph { // 无向图 private int v; // 顶点的个数 private LinkedList adj[]; // 邻接表 public Graph(int v) { this.v = v; adj = new LinkedList[v]; for (int i=0; i(); } } public void addEdge(int s, int t) { // 无向图一条边存两次 adj[s].add(t); adj[t].add(s); } } bfs 的java实现 public void bfs(int s, int t) { if (s == t) return; boolean[] visited = new boolean[v]; visited[s]=true; Queue queue = new LinkedList<>(); queue.add(s); int[] prev = new int[v]; for (int i = 0; i t 的路径 if (prev[t] != -1 && t != s) { print(prev, s, prev[t]); } System.out.print(t + \" \"); } dfs的java实现 boolean found = false; // 全局变量或者类成员变量 public void dfs(int s, int t) { found = false; boolean[] visited = new boolean[v]; int[] prev = new int[v]; for (int i = 0; i img](/asserts/img/8778201ce6ff7037c0b3f26b83efba85.jpg) Swift 版本的bfs和dfs 实现： https://github.com/quding0308/KDAlgorithmKit/blob/master/KDAlgorithmKit/Classes/DataStructure/Graph.swift 参考 https://time.geekbang.org/column/article/70891 "},"algorithm/basic/PriorityQueue.html":{"url":"algorithm/basic/PriorityQueue.html","title":"优先队列","keywords":"","body":"优先队列 优先队列 参考：https://mp.weixin.qq.com/s/CdK1l2kB3aCUtBORjS4DVQ 普通队列 是 先进先出 优先队列不再遵循先入先出的原则，而是分为两种情况： 最大优先队列，无论入队顺序，当前最大的元素优先出队 最小优先队列，无论入队顺序，当前最小的元素优先出队 使用数组实现 复杂度为 O(n)，并不是最理想的方式 使用二叉堆实现，复杂度为 O(log(n)) "},"algorithm/sort/":{"url":"algorithm/sort/","title":"排序","keywords":"","body":"排序 评价一个排序算法，需要从执行效率、内存消耗和稳定性三个方面来看 "},"algorithm/sort/sort1.html":{"url":"algorithm/sort/sort1.html","title":"基础排序","keywords":"","body":"比较 从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。 冒泡排序 是原地排序 是稳定排序 时间复杂度：O(n^2) // 冒泡排序，a是数组，n表示数组大小 public static void bubbleSort(int[] a, int n) { if (n a[j+1]) { // 交换 int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; // 此次冒泡有数据交换 flag = true; } } if (!flag) break; // 没有数据交换，提前退出 } } 插入排序 是原地排序 是稳定排序 时间复杂度：O(n^2) 第n个元素 保证前n个元素有序，然后取第n个元素与前n-1个元素比较，找到合适的位置插入，保证前n个元素有序。 // 插入排序，a 表示数组，n 表示数组大小 public void insertionSort(int[] a, int n) { if (n = 0; j--) { if (a[j] > value) { a[j+1] = a[j]; // 数据移动 } else { break; } } a[j+1] = value; // 插入数据 } } 选择排序 是原地排序 不是稳定排序 时间复杂度：O(n^2) 选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。 // 选择排序，a表示数组，n表示数组大小 public void selectionSort(int[] a, int n) { if (n 希尔排序 https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F "},"algorithm/sort/sort2.html":{"url":"algorithm/sort/sort2.html","title":"归并排序","keywords":"","body":"归并排序 Merge Sort 如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。 不是原地排序 是稳定排序 时间复杂度：O(n * log(n)) public class MergeSort { // 归并排序算法, a是数组，n表示数组大小 public static void mergeSort(int[] a, int n) { mergeSortInternally(a, 0, n-1); } // 递归调用函数 private static void mergeSortInternally(int[] a, int p, int r) { // 递归终止条件 if (p >= r) return; // 取p到r之间的中间位置q int q = (p+r)/2; // 分治递归 mergeSortInternally(a, p, q); mergeSortInternally(a, q+1, r); // 将A[p...q]和A[q+1...r]合并为A[p...r] merge(a, p, q, r); } private static void merge(int[] a, int p, int q, int r) { int i = p; int j = q+1; int k = 0; // 初始化变量i, j, k int[] tmp = new int[r-p+1]; // 申请一个大小跟a[p...r]一样的临时数组 while (i "},"algorithm/sort/sort3.html":{"url":"algorithm/sort/sort3.html","title":"快速排序","keywords":"","body":"快速排序 Quick Sort public class QuickSort { // 快速排序，a是数组，n表示数组的大小 public static void quickSort(int[] a, int n) { quickSortInternally(a, 0, n-1); } // 快速排序递归函数，p,r为下标 private static void quickSortInternally(int[] a, int p, int r) { if (p >= r) return; int q = partition(a, p, r); // 获取分区点 quickSortInternally(a, p, q-1); quickSortInternally(a, q+1, r); } private static int partition(int[] a, int p, int r) { int pivot = a[r]; int i = p; for(int j = p; j O(n) 时间复杂度内求无序数组中的第 K 大元素 使用快排的思想 我们选择数组区间 A[0…n-1] 的最后一个元素 A[n-1] 作为 pivot，对数组 A[0…n-1] 原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。 如果 p+1=K，那 A[p] 就是要求解的元素；如果 K>p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间，我们再按照上面的思路递归地在 A[p+1…n-1] 这个区间内查找。同理，如果 K如何优化快速排序 三数取中法 从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。 随机法 随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。 "},"algorithm/sort/sort4.html":{"url":"algorithm/sort/sort4.html","title":"桶排序","keywords":"","body":"桶排序 Bucket sort 核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。 使用桶排序的前置条件 要排序的数据很容易划分到m个桶，并且桶与桶之间有着大小顺序 数据在各个桶之间的分布是比较均匀的。 桶排序的时间复杂度为什么是 O(n)。适合用于排布排序中，数据存储在磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。 计数排序 计数排序是桶排序的一种特殊情况。 当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。 如何根据年龄给100万用户排序？ 我们假设年龄的范围最小 1 岁，最大不超过 120 岁。我们可以遍历这 100 万用户，根据年龄将其划分到这 120 个桶里，然后依次顺序遍历这 120 个桶中的元素。这样就得到了按照年龄排序的 100 万用户数据。 "},"algorithm/linkedlist/":{"url":"algorithm/linkedlist/","title":"链表","keywords":"","body":"链表 顺序表 是在计算机内存中以数组的形式保存的线性表，是指用一组地址连续的存储单元依次存储数据元素的线性结构。 顺序表的复杂度 随机插入、删除 O(n) 访问随机元素 O(1) 链表 是一种线性表。 但是并不会按线性的顺序存储数据，而是每一个节点存储下一个节点的指针。 链表的复杂度 随机插入、删除 O(1) 访问随机元素 O(n) 链表分为： 单向链表 双向链表 循环链表 块状链表 "},"algorithm/linkedlist/reverseList.html":{"url":"algorithm/linkedlist/reverseList.html","title":"单链表翻转","keywords":"","body":"单链表翻转 class Node { var value: Int = 0 var next: Node? } /// 单链表 翻转 /// 非递归方法 遍历 改变每个node的next的指向 /// 使用两个指针配合工作，使得两个节点间的指向反向，同时用r记录剩下的链表。 func reverseList2(head: Node?) -> Node? { var pre = head var cur = head?.next head?.next = nil while let _ = cur { let tmp = cur?.next cur?.next = pre pre = cur cur = tmp } return pre } /// 非递归方法 遍历 每次取一个放入到第一个元素中 /// 对于一条链表，从第2个节点到第N个节点，依次逐节点插入到第1个节点(head节点)之后，(N-1)次这样的操作结束之后将第1个节点挪到新表的表尾即可。 /// 代码跟上面的一样 但思路不太一样 func reverseList3(head: Node?) -> Node? { var curHead = head var next = curHead?.next while let _ = next { let tmp = next?.next next?.next = curHead curHead = next next = tmp } head?.next = nil return curHead } /// 递归操作 思路 /** 链表：a->b->c->d 递归过程： a->b->c->d a->(b->c->d) a->(b->(c->d)) a->(b->(c(b Node? { if let next = head?.next { var newHead = reverseList(head: next) newHead?.next = head head?.next = nil return newHead } return head } "},"algorithm/linkedlist/circle.html":{"url":"algorithm/linkedlist/circle.html","title":"单链表是否有环、环节点、长度","keywords":"","body":"如何判断一个单链表是否有环？ 方式1：遍历链表 寻找是否有相同的地址 func hasCircle2() -> Bool { var n = head while let node = n { var next = node.next if node === next { return true } while let node2 = next?.next { if node === node2 { return true } next = node2 } n = node.next } return false } 复杂度为n^2 方式2：经典方式 extension SinglyLinkedList { func hasCircle() -> Bool { var slowStep = head var quickStep = head?.next while let quick = quickStep, let slow = slowStep { if quick === slow { return true } else { quickStep = quickStep?.next?.next slowStep = slowStep?.next } } return false } } 算法复杂度为O(n) 求环的入口 寻找环入口的方法就是采用两个指针，一个从表头出发，一个从相遇点出发，一次都只移动一步，当二者相等时便是环入口的位置。 func detectCycle() -> Node? { var slowStep = head var quickStep = head?.next var cross: Node? = nil while let quick = quickStep, let slow = slowStep { if quick === slow { cross = quick } else { quickStep = quickStep?.next?.next slowStep = slowStep?.next } } var headWalker = head var crossWalker = cross while let _ = headWalker?.next, let _ = crossWalker?.next, headWalker !== crossWalker { crossWalker = crossWalker?.next headWalker = headWalker?.next } if headWalker === crossWalker { return headWalker } return nil } 数学推到： 参考 求环的长度 知道环的入口后，继续往下走 直到下次到入口走的距离就是 环的长度 "},"algorithm/symbolTable/":{"url":"algorithm/symbolTable/","title":"符号表","keywords":"","body":"符号表 英文 Symbol Table，简称 SB 符号表是一种典型的抽象数据类型 ADT 。它最主要的目的就是将一个键和一个值联系起来。 定义的api如下 /// Symbol Table class ST { func put(key: Key, value: Value) func get(key: Key) -> Value? func delete(key: Key) func contains(key: Key) -> Bool func isEmpty() -> Bool func size() -> Int } 符号表的几种实现 基于无序链表实现 基于有序数组实现 基于散列表实现 "},"algorithm/symbolTable/hashTable.html":{"url":"algorithm/symbolTable/hashTable.html","title":"哈希表","keywords":"","body":"散列表 HashTable 我们通过一个数组来实现无序的符号表。 通过散列函数hash() 将key转换为小整数，该整数作为数组的索引。 这样就可以快速访问任意key对应的value。 通过key找到索引分为两步： 用散列函数将key转化为一个索引 处理碰撞冲突 散列函数 假设有一个能保存M个键值的数组，我们需要一个散列函数，能够把任意key转化为在[0,M-1]范围内的索引。 具体散列函数 跟 key 的类型有关 除留余数法 // key为正整数 hashCode = k % M 好的散列函数需要满足三个条件： 一致性 高效性 计算速度快，简单 均匀性 均匀的散列所有键 碰撞冲突处理 基于拉链法的散列表 将大小为M的数组中每个元素指向一个链表，链表中的每个节点存储了散列值为该元素的索引的键值对。 基于线性探测法的散列表 用大小为M的数组保存N个键值对(M > N)。当碰撞发生时，索引加1，检测散列表中下一个位置，有3种可能： 命中。该位置的键好被查找的键相同 未命中，键为空 停止查找，没有找到元素 未命中，键不相等，继续查找 "},"algorithm/binarytree/":{"url":"algorithm/binarytree/","title":"二叉树","keywords":"","body":" tree 树是一种抽象的数据类型 用来模拟具有树状结构性质的数据集合 具有如下特点： 每个节点有零个或多个子节点； 没有父节点的节点称为根节点； 每一个非根节点有且只有一个父节点； 除了根节点外，每个子节点可以分为多个不相交的子树； 二叉树 是每个节点最多有两个分支的树。 分支 为 左子树、右子树 二叉树分支 具有左右次序，不可颠倒 https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%B1%BB%E5%9E%8B root 根节点 node 子节点(还有子节点) leaf 页子节点(没有子节点) k 二叉树的总层数 h 第h层 满二叉树 complete binary tree 一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。 如果一个二叉树的层数为K，且结点总数是(2^k) - 1 ，则它就是满二叉树。 如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树 满二叉树具有的特点： 1.一个层数为 k 的满二叉树总结点数为(2^k) - 1 2.第i层上节点数为2^(i-1) 3.一个层数为k的满二叉树的叶子结点个数（也就是最后一层）： 2^(k-1) 完全二叉树 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。 完全二叉树通常采用数组而不是链表存储 完全二叉树中第i层至多有2^(i-1）个节点， 完全二叉树最多有2^k - 1个节点。 完全二叉树的特点是： 1. 只允许最后一层有空缺结点且空缺在右边，即叶子结点只能在层次最大的两层上出现； 2. 对任一结点，如果其右子树的深度为j，则其左子树的深度必为j或j+1。 即度为1的点只有1个或0个 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。 存数方式： 顺序存储表示。使用数组存储 2.二叉链表存储表示。 "},"algorithm/binarytree/travesal.html":{"url":"algorithm/binarytree/travesal.html","title":"二叉树遍历","keywords":"","body":"dd11 "},"algorithm/binarytree/binaryheap.html":{"url":"algorithm/binarytree/binaryheap.html","title":"二叉堆","keywords":"","body":"二叉堆 binary heap 本质是一个完全二叉树 分为两类： 最大堆 root 为最大值 最小堆 root 为最小值 对外操作： 插入新element 获取最大或最小值 内部操作： 插入节点 插入节点后 下沉 删除节点 删除节点后 上浮 /** */ class BinaryHeap: NSObject { public func insert(_ element: Int) { } // 最大堆 public func root() -> Int { return 0 } } class MaxBinaryHeap: NSObject { private var array = [Int]() public func insert(_ element: Int) { array.append(element) MaxBinaryHeap.upValue(array: &array, index: array.endIndex) } // 最大堆 public func root() -> Int? { let first = array.first // 把最后一个拿到root位置 array.swapAt(array.startIndex, array.endIndex) array.removeLast() // array 的length就是真实的堆中的元素个数 MaxBinaryHeap.downValueMaxHeap(array: &array, parrentIndex: 0) return first } /// 插入一个值后，执行up操作 【最后一个值up】 /// /// - Parameters: /// - array: /// - index: childIndex fileprivate static func upValue(array: inout [Int], index: Int) { if index == 0 { return } let parentIndex = index / 2 if array[parentIndex] 0 { // recursive 直到root upValue(array: &array, index: parentIndex) } } } /// 取出一个root后 用最后一个值填充，执行down操作 【root改变后 down】 /// /// - Parameters: /// - array: /// - index: parentIndex fileprivate static func downValueMaxHeap(array: inout [Int], parrentIndex: Int) { if parrentIndex >= array.endIndex { return } var childIndex = parrentIndex * 2 + 1 // 找到child node中大的那个 if childIndex + 1 array[parrentIndex] { array.swapAt(childIndex, parrentIndex) downValueMaxHeap(array: &array, parrentIndex: childIndex) } } } "},"algorithm/search/":{"url":"algorithm/search/","title":"搜索","keywords":"","body":""},"algorithm/search/dfs.html":{"url":"algorithm/search/dfs.html","title":"深度优先搜索","keywords":"","body":"深度优先搜索 Depth-First-Search，以下简称DFS 一个二叉树如下 5 / \\ 2 3 / \\ / \\ 1 7 9 8 / 6 DFS的搜索过程为： 5 2->1->6->7 3->9->8 "},"algorithm/search/bfs.html":{"url":"algorithm/search/bfs.html","title":"广度优先搜索","keywords":"","body":"广度优先搜索 Breadth-First-Search，以下简称BFS "},"algorithm/search/binarySearch.html":{"url":"algorithm/search/binarySearch.html","title":"广度优先搜索","keywords":"","body":"二分查找 二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0 使用二分查找的前置条件 二分查找依赖顺序表结构 数组 二分查找针对的是有序数据 数据量太小不适合二分查找 数据量太大不适合二分查找 查找速度 O(logn) public int bsearch(int[] a, int n, int value) { int low = 0; int high = n - 1; while (low 递归实现 // 二分查找的递归实现 public int bsearch(int[] a, int n, int val) { return bsearchInternally(a, 0, n - 1, val); } private int bsearchInternally(int[] a, int low, int high, int value) { if (low > high) return -1; int mid = low + ((high - low) >> 1); if (a[mid] == value) { return mid; } else if (a[mid] 如何在 1000 万个整数中快速查找某个整数？ 我们的内存限制是 100MB，每个数据大小是 8 字节，最简单的办法就是将数据存储在数组中，内存占用差不多是 80MB，符合内存的限制。借助今天讲的内容，我们可以先对这 1000 万数据从小到大排序，然后再利用二分查找算法，就可以快速地查找想要的数据了。 "},"algorithm/other/":{"url":"algorithm/other/","title":"其他","keywords":"","body":"other "},"algorithm/other/fibonacci.html":{"url":"algorithm/other/fibonacci.html","title":"斐波切纳数列","keywords":"","body":"斐波那契数列 又称为 黄金分割数列 或 兔子数列 黄金分割 随着数列项数的增加，前一项与后一项之比越来越逼近黄金分割的数值0.6180339887.. 指的是这样一个数列： 0、1、1、2、3、5、8、13、21、34、... 数学表示： f(1) = 1 f(2) = 1 f(n) = f(n -1) + f(n - 2) 程序表示： /// 递归表示 斐波那契数列 /// 时间复杂度为 O(2^n) /// /// - Parameter n: 数列中第n位的值 /// - Returns: func fibonacci_recursion(n: UInt) -> UInt { if n == 0 { return 0 } else if n == 1 { return 1 } return fibonacci_recursion(n: n - 1) + fibonacci_recursion(n: n - 2) } 复杂度计算：f(4)的表示 f(4) / \\ f(3) f(2) / \\ / \\ f(2) f(1) f(1) f(0) / \\ f(1) f(0) 一个k层满二叉树的节点数为 2^k - 1 f(n)是一个树高为n的二叉树 近似计算复杂度为 O(2^n) /// 迭代计算 斐波切纳数列 /// 时间复杂度为 O(n) 空间复杂度为 O(1) /// - Parameter n: /// - Returns: func fibonacci_iterator(n: UInt) -> UInt { if n == 0 { return 0 } else if n == 1 { return 1 } else { var a: UInt = 1 var b: UInt = 1 var c: UInt = 1 for _ in 2.."},"algorithm/other/gongyueshu.html":{"url":"algorithm/other/gongyueshu.html","title":"求最大公约数","keywords":"","body":"求最大公约数 /// 递归实现 复杂度高 int gcd(int a,int b) { if(a%b) return gcd(b,a%b); return b; } /* c语言的实现 */ void swapi(int *x, int *y) { int tmp = *x; *x = *y; *y = tmp; } int gcd(int m, int n) { int r; do { if (m "},"algorithm/other/yuesefu.html":{"url":"algorithm/other/yuesefu.html","title":"约瑟夫问题","keywords":"","body":"约瑟夫问题 问题描述： N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。 例如N=6，M=5，被杀掉的顺序是：5，4，6，2，3，1。 解法 用循环单链模拟整个过程，时间复杂度为O(m*n) class Node { var next: Node? var index: Int init(index: Int) { self.index = index print(index) } } func createCycle(n: Int) -> Node? { let head = Node(index: 1) var node = head var count = 1 while count 参考 "},"algorithm/other/lcsubstring.html":{"url":"algorithm/other/lcsubstring.html","title":"最长公共子串","keywords":"","body":"最长公共子串 最长公共子串（Longest Common Substring）与最长公共子序列（Longest Common Subsequence）的区别： 子串要求在原字符串中是连续的，而子序列则只需保持相对顺序一致，并不要求连续。例如X = {a, Q, 1, 1}; Y = {a, 1, 1, d, f}那么，{a, 1, 1}是X和Y的最长公共子序列。{1, 1} 是X和Y的最长公共子字符串。 思路 最长公共子串存在最优子结构：这个问题可以分解成更小，更简单的“子问题” 最长公共子串问题的子问题的解是可以重复使用的，也就是说，更高级别的子问题通常会重用低级子问题的解。 拥有这个两个属性的问题可以使用动态规划算法来解决，这样子问题的解就可以被储存起来，而不用重复计算。 求 \"ABCBDABA\" 与 \"BDCABA\" 的最长公共子串 1.建二维数组 使用一个二维数组存储子问题的结果方便复用，f[i][j]存储X[i]和Y[j]之前的最长公共子串长度。 2.计算规则： if x[i] == y[j] { c[i,y] = c[i-1,j-1] + 1 } else { c[i,y] = 0 } 3.二维数组中最大的数就是最长子串 根据计算规则，可以倒推出最长二位子序列为 \"ABA\" 代码实现 // 最长子串 static func lcs1(str1: String, str2: String) -> String? { // 行数 str1.count 列数 str2.count var arr = [[Int]](repeating: [Int](repeating: 0, count: str2.count+1), count: str1.count+1) var maxRow = 0 var maxColumn = 0 var max = 0 for i in 1...str1.count { for j in 1...str2.count { if str1[str1.index(str1.startIndex, offsetBy: i-1)] == str2[str2.index(str2.startIndex, offsetBy: j-1)] { arr[i][j] = arr[i - 1][j - 1] + 1 if max 0 { result.insert(str1[str1.index(str1.startIndex, offsetBy: maxRow-1)], at: result.startIndex) maxRow -= 1 maxColumn -= 1 } else { break } } return result } "},"algorithm/other/lcsubsequence.html":{"url":"algorithm/other/lcsubsequence.html","title":"最长公共子序列","keywords":"","body":"最长公共子序列 最长公共子串（Longest Common Substring）与最长公共子序列（Longest Common Subsequence）的区别： 子串要求在原字符串中是连续的，而子序列则只需保持相对顺序一致，并不要求连续。例如X = {a, Q, 1, 1}; Y = {a, 1, 1, d, f}那么，{a, 1, 1}是X和Y的最长公共子序列。{1, 1} 是X和Y的最长公共子字符串。 思路 最长公共子序列问题存在最优子结构：这个问题可以分解成更小，更简单的“子问题”，这个子问题可以分成更多的子问题 最长公共子序列问题的子问题的解是可以重复使用的，也就是说，更高级别的子问题通常会重用低级子问题的解。 拥有这个两个属性的问题可以使用动态规划算法来解决，这样子问题的解就可以被储存起来，而不用重复计算。 求 \"ABCBDAB\" 与 \"BDCABA\" 的最长公共子序列 1.建二维数组 使用一个二维数组存储子问题的结果方便复用，f[i][j]存储X[i]和Y[j]之前的最长公共子序列长度。 2.计算规则： 3.二维数组中最大的数就是最长子序列 根据计算规则，可以倒推出最长二位子序列为 \"BCBA\" 代码实现 // 最长子序列 static func lcs2(str1: String, str2: String) -> String? { // 行数 str1.count 列数 str2.count var arr = [[Int]](repeating: [Int](repeating: 0, count: str2.count + 1), count: str1.count + 1) var maxRow = 0 var maxColumn = 0 var max = 0 for i in 1...str1.count { for j in 1...str2.count { if str1[str1.index(str1.startIndex, offsetBy: i-1)] == str2[str2.index(str2.startIndex, offsetBy: j-1)] { arr[i][j] = arr[i-1][j-1] + 1 if max arr[i][j-1] { arr[i][j] = arr[i-1][j] } else { arr[i][j] = arr[i][j-1] } } } } var result: String = \"\" while true { if arr[maxRow][maxColumn] > 0 { if arr[maxRow][maxColumn] > arr[maxRow-1][maxColumn], arr[maxRow][maxColumn] > arr[maxRow][maxColumn-1] { result.insert(str1[str1.index(str1.startIndex, offsetBy: maxRow-1)], at: result.startIndex) maxRow -= 1 maxColumn -= 1 } else { if arr[maxRow-1][maxColumn] > arr[maxRow][maxColumn-1] { maxRow -= 1 } else { maxColumn -= 1 } } } else { break } } return result } 参考 https://zh.wikipedia.org/wiki/最长公共子序列 https://www.kancloud.cn/digest/pieces-algorithm/163624 "},"algorithm/other/dp-bag.html":{"url":"algorithm/other/dp-bag.html","title":"背包问题","keywords":"","body":"背包问题 "},"oc/":{"url":"oc/","title":"Objective-C","keywords":"","body":"底层实现原理 block 底层实现 runtime 和 对象模型 observer 的实现 网络 http 知识复习。raw 拷贝一份 懂 https 原理清晰。几个 role，cert 怎么流转，加密方式 tcp 原理描述 基于mars 改进 相比 websocket 的优点 websocket 基本原理，在 有赞的 优化点？ mars 相比 socket tcp，做了哪些优化点？ App网络优化 http://blog.cnbang.net/tech/3531/ 数据库 wcdb 相比直接使用 fmdb 的优点，解决了之前的哪些坑？ wcdb 的基本原理，项目中怎么用？ protobuf 与 现在项目中技术方案比较？ 索引的建立 优缺点 表的拆分？ 轻应用 负责承载基础业务 wk的一些基础api 相比于 UIWebView的一些优势 开发 混合应用的 整个思考过程，相比较VaSonic 的使用？ 【查看最新版本】 首页秒开探索：http://blog.cnbang.net/tech/3477/ IM 的相关策略 如何保证可达性？ 如何尽快拉取？ 等 文档里的描述 总结成可以说的问题 UI渲染流程，事件响应机制 卡顿问题 如何监测 Autolayout 的使用 UIStackView 的常见使用？我为什么没有用？ 动画 lottie 库的使用，常见问题 pop库的使用 Texture 中提供的优化思路 gif动画播放原理 以及 压缩思路 内存问题 如何分配？ 如何检测泄露 如何监测内存占用？ 如何优化内存，常见思路？ FBRetainCycleDetector MLeaksFinder 底层问题 oc部分底层实现原理 CoreText问题 Text绘制慢，如何优化？ runtime 对象模型 动态特性 锁、GCD、RunLoop 其他框架： promisekit rxswift SDWebImage YYCache的缓存设计 如果自己设计一个缓存系统？ App启动时间优化 以及 启动时做了什么 编译流程 iOS签名原理：http://blog.cnbang.net/tech/3386/ 【绘制一张mindmap】 线程 和 进程 的不同 Android单启动一个进程，面向进程编程的不同？ 检测、量化 -> 瓶颈 -> 优化 😋 启动流程 运行时与对象模型 map 与 flatmap differentor 的使用，tableview 优化 再整理下 block new 与 alloc 区别 // 使用 _zoneAlloc 分配内存，自己显示调用 initXX 来初始化对象 + alloc { return (*_zoneAlloc)((Class)self, 0, malloc_default_zone()); } // 使用 _alloc 分配内存，只能使用 init 初始化对象 + new { id newObject = (*_alloc)((Class)self, 0); Class metaClass = self->isa; if (class_getVersion(metaClass) > 1) return [newObject init]; else return newObject; } - init { return self; } 补充： NSZone是Apple用来分配和释放内存的一种方式，它不是一个对象，而是使用C结构存储了关于对象的内存管理的信息。iOS App 使用一个系统默认的NSZone来对应用的对象进行管理，会对内存做一定优化，减少内存碎片。 nil 输出到 字符串中为 (null) NSString *str = nil; NSString *result = [NSString stringWithFormat:@\"result:%@\", str]; 输出： result:(null) //////// 其他为nil 的对象 MyKey *str = nil; NSString *result = [NSString stringWithFormat:@\"result:%@\", str]; 输出： result:(null) "},"oc/runtime/":{"url":"oc/runtime/","title":"runtime","keywords":"","body":"Runtime "},"oc/runtime/runtime-model.html":{"url":"oc/runtime/runtime-model.html","title":"对象模型","keywords":"","body":"Runtime 对象模型 实际使用场景： 方法互换 动态添加成员变量和方法 获得某个类的所有成员变量和方法 model与字典互相转 分类增加属性 "},"oc/runtime/runtime-msg.html":{"url":"oc/runtime/runtime-msg.html","title":"消息分发","keywords":"","body":"Runtime 消息分发机制 像对象发送一个消息，会在 Runtime 中调用： objc_msgSend(receiver, selector, arg1, arg2, ...) 消息转发 消息转发机制基本分为三个步骤： 动态方法解析 备用接受者 完整转发 第一步：动态方法解析 对象在接收到未知的消息时，首先会调用下面方法： + (BOOL)resolveInstanceMethod:(SEL)sel + (BOOL)resolveClassMethod:(SEL)sel 示例： #import - (void)viewDidLoad { [super viewDidLoad]; [self performSelector:@selector(unknownMethod)]; } + (BOOL)resolveInstanceMethod:(SEL)sel { NSString *selectorString = NSStringFromSelector(sel); // 对 unknownMethod 方法的调用被截获了并在 dealWithExceptionForUnknownMethod 函数中进行了处理，程序没有再崩溃。@dynamic 属性就可以用这种方案来实现 if ([selectorString isEqualToString:@\"unknownMethod\"]) { class_addMethod(self.class, @selector(unknownMethod), (IMP) dealWithExceptionForUnknownMethod, \"v@:\"); } return [super resolveInstanceMethod:sel]; } void dealWithExceptionForUnknownMethod(id self, SEL _cmd) { NSLog(@\"%@, %p\", self, _cmd); // Print: , 0x1078259fc } 第二步：备用接收者 如果在第一步还是无法处理消息，则 Runtime 会继续调用： -(id)forwardingTargetForSelector:(SEL)aSelector 如果一个对象实现了这个方法，并返回一个非 nil 的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是 self 自身，否则就会出现无限循环。当然，如果我们没有指定相应的对象来处理 aSelector，则应该调用父类的实现来返回结果。 - (id)forwardingTargetForSelector:(SEL)aSelector { NSString *selectorString = NSStringFromSelector(aSelector); if ([selectorString isEqualToString:@\"unknownMethod2\"]) { return [[RuntimeMethodHelper alloc] init]; } return [super forwardingTargetForSelector:aSelector]; } 第三步：完整转发 如果前两步未处理消息，那么接下来只有启用完整的消息转发机制了，这时候会调用以下方法： - (void)forwardInvocation:(NSInvocation *)anInvocation - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector 对象会创建一个表示消息的 NSInvocation 对象，消息有关的全部细节都封装在 NSInvocation 对象中，包括：selector、目标(target)和参数。我们可以在 -forwardInvocation: 方法中选择将消息转发给其它对象。 - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { NSMethodSignature *signature = [super methodSignatureForSelector:aSelector]; if (!signature) { if ([RuntimeMethodHelper instancesRespondToSelector:aSelector]) { signature = [RuntimeMethodHelper instanceMethodSignatureForSelector:aSelector]; } } return signature; } - (void)forwardInvocation:(NSInvocation *)anInvocation { if ([RuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) { [anInvocation invokeWithTarget:[[RuntimeMethodHelper alloc] init]]; } } doesNotRecognizeSelector 如果消息没有被处理，最后就会 走到 NSObject 的 doesNotRecognizeSelector - (void)doesNotRecognizeSelector:(SEL)aSelector { NSLog(@\"doesNotRecognizeSelector\"); } 使用案例 参考 "},"oc/runtime/api/":{"url":"oc/runtime/api/","title":"API","keywords":"","body":"Runtime 运行时api runtime是OC底层的一套c语言API。编译器会把oc代码编译成运行时代码，调用的就是runtime接口。 两个头文件： #import #import 涉及的概念 struct objc_ivar_list { int ivar_count； struct objc_ivar ivar_list[1]; // 数组 } struct objc_method_list { int method_count; struct objc_method method_list[1]; // 数组 } struct objc_protocol_list { struct objc_protocol_list *next; long count; Protocol *list[1]; }; // 更多参考 objc_cache 的文章 struct objc_cache { unsigned int mask; unsigned int occupied; Method buckets[1]; }; id typedef struct objc_object *id; struct objc_object { Class isa; // 指向 class } 当向 object 发消息时，object 会根据 isa 找到 class，首先会从 class 的 objc_cache 中寻找，然后从 class 和其父类 的 methodList中寻找对应的方法运行。 SEL 选择器表示一个方法的selector的指针，可以理解为Method中的ID类型 typedef struct objc_selector *SEL; 标识运行时一个方法的名字（在编译阶段，根据名称生成一个唯一的整数） 获取SEL的三个方法： sel_registerName函数 objectivec编译器提供的@selector() NSSelectorFromString()方法 Category typedef struct objc_category *Category; // 一个category struct objc_category { char *category_name OBJC2_UNAVAILABLE; char *class_name OBJC2_UNAVAILABLE; struct objc_method_list *instance_methods OBJC2_UNAVAILABLE; struct objc_method_list *class_methods OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; } IMP 函数指针 typedef id(*IMP)(id, SEL, ...) Method typedef struct objc_method *Method; struct objc_method { SEL method_name; // 函数名 SEL char *method_types; // 函数原型字符串 IMP method_imp; // IMP 地址 } Ivar typedef struct objc_ivar *Ivar; // 实例变量 struct objc_ivar { char *ivar_name; // 变量名 char *ivar_type; // 变量类型 int ivar_offset; // 偏移量 根据class结构体的地址加上基地址偏移字节得到的。 } objc_property_t 一个属性必然对应一个成员变量，还会根据属性修饰符，对成员变量进行一系列封装 typedef struct objc_property *objc_property_t; 通过class_copyPropertyList和protocol_copyPropertyList方法获取类和协议的属性 objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount) objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount) struct objc_property { // } //Defines a property attribute typedef struct { const char *name; The name of the attribute const char *value; Protocol typedef struct objc_object Protocol; api Class Class cls = RuntimeTest.class; Class superCls = class_getSuperclass(cls); BOOL isMeta = class_isMetaClass(cls); size_t instanceSize = class_getInstanceSize(cls); int version = class_getVersion(cls); class_setVersion(cls, 20); int version1 = class_getVersion(cls); /// === ivars Ivar varB = class_getInstanceVariable(cls, \"b\"); // 添加成员变量 BOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types ); //这个只能够向在runtime时创建的类添加成员变量 // 获取整个成员变量列表 Ivar * class_copyIvarList ( Class cls, unsigned int *outCount ); //必须使用free()来释放这个数组 /// Methods // 添加方法 BOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types ); //和成员变量不同的是可以为类动态添加方法。如果有同名会返回NO，修改的话需要使用method_setImplementation // 获取实例方法 Method class_getInstanceMethod ( Class cls, SEL name ); // 获取类方法 Method class_getClassMethod ( Class cls, SEL name ); // 获取所有方法的数组 Method * class_copyMethodList ( Class cls, unsigned int *outCount ); // 替代方法的实现 IMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types ); // 返回方法的具体实现 IMP class_getMethodImplementation ( Class cls, SEL name ); IMP class_getMethodImplementation_stret ( Class cls, SEL name ); // 类实例是否响应指定的selector BOOL class_respondsToSelector ( Class cls, SEL sel ); objc_protocol_list // 添加协议 BOOL class_addProtocol ( Class cls, Protocol *protocol ); // 返回类是否实现指定的协议 BOOL class_conformsToProtocol ( Class cls, Protocol *protocol ); // 返回类实现的协议列表 Protocol * class_copyProtocolList ( Class cls, unsigned int *outCount ); 参考 https://www.jianshu.com/p/f48ce7225cf8 https://ming1016.github.io/2015/04/01/objc-runtime/ 官方网站：https://developer.apple.com/documentation/objectivec/objective-c_runtime?language=objc "},"oc/runtime/api/library.html":{"url":"oc/runtime/api/library.html","title":"获取library","keywords":"","body":"Library objc_copyImageNames Returns the names of all the loaded Objective-C frameworks and dynamic libraries. class_getImageName Returns the name of the dynamic library a class originated from. objc_copyClassNamesForImage Returns the names of all the classes within a specified library or framework. "},"oc/runtime/api/class.html":{"url":"oc/runtime/api/class.html","title":"操作class、创建Class、实例化对象","keywords":"","body":"添加 Class、实例化对象 runtime api objc_allocateClassPair Creates a new class and metaclass. objc_disposeClassPair Destroys a class and its associated metaclass. objc_registerClassPair Registers a class that was allocated using objc_allocateClassPair. objc_duplicateClass Used by Foundation's Key-Value Observing. Instantiating Classes class_createInstance Creates an instance of a class, allocating memory for the class in the default malloc memory zone. objc_constructInstance Creates an instance of a class at the specified location. objc_destructInstance Destroys an instance of a class without freeing memory and removes any of its associated references. 源码 typedef struct objc_class* Class; typedef struct objc_object* id; struct objc_object { Class isa; }; struct objc_class : objc_object { Class superclass; cache_t cache; /// data 返回的是 class_rw_t* 指针，class_rw_t 存储了 class 的 ivars、methods、protocols等信息 class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() { return bits.data(); } void setData(class_rw_t *newData) { bits.setData(newData); } } class_rw_t rw 为 readwrite struct class_rw_t { uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName; }; class_ro_t ro 为 readonly struct class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; const uint8_t * ivarLayout; // "},"oc/runtime/api/object.html":{"url":"oc/runtime/api/object.html","title":"操作对象","keywords":"","body":"3 "},"oc/runtime/api/method.html":{"url":"oc/runtime/api/method.html","title":"method","keywords":"","body":"概要 typedef struct method_t *Method; struct method_t { SEL name; const char *types; IMP imp; }; objc_class 中的 method 存储在 class_rw_t 中的 method_array_t 中，也包括了 catertoy 添加的 method_t 和 运行时中增加的 method_t。 struct class_rw_t { const class_ro_t *ro; method_array_t methods; } // method_array_t 是存储 method_t 的容器 class method_array_t : public list_array_tt { // } class_ro_t 中有一个属性 baseMethodList 存储的是 class 最开定义的 method_t struct class_ro_t { method_list_t * baseMethodList; }; runtime api Method id method_invoke(id receiver, Method m, ...); void method_invoke_stret(id receiver, Method m, ...); SEL method_getName(Method m); IMP method_getImplementation(Method m); const char * method_getTypeEncoding(Method m); IMP method_setImplementation(Method m, IMP imp); void method_exchangeImplementations(Method m1, Method m2); char * method_copyReturnType(Method m); char * method_copyArgumentType(Method m, unsigned int index); void method_getReturnType(Method m, char *dst, size_t dst_len); void method_getArgumentType(Method m, unsigned int index, char *dst, size_t dst_len); struct objc_method_description * method_getDescription(Method m); class // 遍历查找父类 method Method class_getInstanceMethod(Class cls, SEL name); Method class_getClassMethod(Class cls, SEL name); // 返回当前 class 内存储的 methods (cls->data()->methods) Method _Nonnull * class_copyMethodList(Class cls, unsigned int *outCount); BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types); IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types); IMP class_getMethodImplementation(Class cls, SEL name); IMP class_getMethodImplementation_stret(Class cls, SEL name); 源码实现 get method Method class_getClassMethod(Class cls, SEL sel) { if (!cls || !sel) return nil; return class_getInstanceMethod(cls->getMeta(), sel); } Method class_getInstanceMethod(Class cls, SEL sel) { if (!cls || !sel) return nil; return _class_getMethod(cls, sel); } static Method _class_getMethod(Class cls, SEL sel) { rwlock_reader_t lock(runtimeLock); return getMethod_nolock(cls, sel); } add & replace method BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types) { if (!cls) return NO; rwlock_writer_t lock(runtimeLock); return ! addMethod(cls, name, imp, types ?: \"\", NO); } IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types) { if (!cls) return nil; rwlock_writer_t lock(runtimeLock); return addMethod(cls, name, imp, types ?: \"\", YES); } // add 和 replace 都调用了 addMethod 方法 static IMP addMethod(Class cls, SEL name, IMP imp, const char *types, bool replace) { IMP result = nil; method_t *m; if ((m = getMethodNoSuper_nolock(cls, name))) { // method 已经存在， already exists if (!replace) { // add 不做任何处理，返回已经存在的 imp result = m->imp; } else { // replace 会取出已经存在的 mehtod_t ，然后替换 imp result = _method_setImplementation(cls, m, imp); } } else { // method 还不存在，则会创建 一个 method_list_t，把 method 添加到 method_list_t 中， // 然后把 method_list_t 添加到 cls->data()->methods 中(class_rw_t 所有的 class_array_t 中) method_list_t *newlist; newlist = (method_list_t *)calloc(sizeof(*newlist), 1); newlist->entsizeAndFlags = (uint32_t)sizeof(method_t) | fixed_up_method_list; newlist->count = 1; newlist->first.name = name; newlist->first.types = strdup(types); if (!ignoreSelector(name)) { newlist->first.imp = imp; } else { newlist->first.imp = (IMP)&_objc_ignored_method; } prepareMethodLists(cls, &newlist, 1, NO, NO); // attachLists 会添加到 methods 的最前面，所以每次顺序从 method_array_t 中取 method_t 时，都会优先取出后添加的 method_t 。(这里解释了 category 添加的方法会优先于 class 的方法调用) cls->data()->methods.attachLists(&newlist, 1); flushCaches(cls); result = nil; } return result; } "},"oc/runtime/api/ivar.html":{"url":"oc/runtime/api/ivar.html","title":"ivar","keywords":"","body":"概要 typedef struct ivar_t *Ivar; struct ivar_t { int32_t *offset; const char *name; const char *type; }; struct class_ro_t { // ... const ivar_list_t * ivars; // ... }; offset 指当前 ivar 的内存起始地址 对齐规则： 起始地址是长度的整数倍 64位，struct 长度是8的倍数。32位，struct 长度是4的倍数 @interface RuntimeTest3 () { int8_t age1; NSString *firstName; int32_t age; NSString *lastName; } /* NSString *firstName; NSString *lastName; int32_t age; int8_t age1; 对齐策略为： 0-------- isa 8-------- firstName 16-------- lastName 24-------- age 28-------- age1 实例大小为 32 bytes */ /* int8_t age1; NSString *firstName; NSString *lastName; int32_t age; 对齐策略为： 0-------- isa 8-------- age1 (这里要对齐 btyes) 16-------- firstName 24-------- lastName 32-------- age 实例大小为 40 bytes */ /* int8_t age1; NSString *firstName; int32_t age; NSString *lastName; 对齐策略为： 0-------- isa 8-------- age1 (这里要对齐 btyes) 16-------- firstName 24-------- age 32-------- lastName 实例大小为 40 bytes */ /* int8_t age1; int32_t age; NSString *firstName; NSString *lastName; 对齐策略为： 0-------- isa 8-------- age1 12-------- age 16-------- firstName 24-------- lastName 实例大小为 32 bytes */ 存储 objc_class->data() 会返回 class_rw_t。 class_rw_t->ro 持有 class_ro_t。class_ro_t 中持有 ivars 用于保存 class 的 Ivar。 objc_class ->data() // class_rw_t。 ->ro() // class_ro_t。class_ro_t ->ivars // const ivar_list_t* ivars ivar_list_t 继承自 entsize_list_tt， entsize_list_tt 可以理解为一个容器，拥有自己的迭代器用于遍历所有元素。 Element 表示元素类型，List 用于指定容器类型，最后一个参数为标记位。 // ivar_list_t 是存储 ivar_t 的容器 struct ivar_list_t : entsize_list_tt { }; struct entsize_list_tt { uint32_t entsizeAndFlags; uint32_t count; Element first; }; runtime api ivar const char * ivar_getName(Ivar v); ptrdiff_t ivar_getOffset(Ivar v); const char * ivar_getTypeEncoding(Ivar v); 源码实现 // name const char* ivar_getName(Ivar ivar) { if (!ivar) return nil; return ivar->name; } // ptrdiff_t 类型变量通常用来保存两个指针减法操作的结果。 // ptrdiff_t 是 C/C++ 标准库中定义的一个与机器相关的数据类型。size_t 类型用于指明数组长度,它必须是一个正数; ptrdiff_t 类型则应保证足以存放同一数组中两个指针之间的差距，它有可能是负数 ptrdiff_t ivar_getOffset(Ivar ivar) { if (!ivar) return 0; return *ivar->offset; } const char* ivar_getTypeEncoding(Ivar ivar) { if (!ivar) return nil; return ivar->type; } class api // 首先会遍历自己，然后查找父类 直到找到 Ivar class_getClassVariable(Class cls, const char *name); Ivar class_getInstanceVariable(Class cls, const char *name); // class_addIvar 只能在 objc_allocateClassPair 和 objc_registerClassPair 之间调用。 // 已经存在的类不支持添加 ivar。 BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types); // 只会遍历当前类的 var ，不会去父类查找 Ivar _Nonnull * class_copyIvarList(Class cls, unsigned int *outCount); const uint8_t * class_getIvarLayout(Class cls); void class_setIvarLayout(Class cls, const uint8_t *layout); const uint8_t * class_getWeakIvarLayout(Class cls); void class_setWeakIvarLayout(Class cls, const uint8_t *layout); 源码实现 get variable 的实现 // 获取 class 的 ivar 相当于是 metaclass 的 instance ivar Ivar class_getClassVariable(Class cls, const char *name) { if (!cls) return nil; return class_getInstanceVariable(cls->ISA(), name); } // 获取 instance 的 ivar Ivar class_getInstanceVariable(Class cls, const char *name) { if (!cls || !name) return nil; return _class_getVariable(cls, name, nil); } Ivar _class_getVariable(Class cls, const char *name, Class *memberOf) { rwlock_reader_t lock(runtimeLock); // 递归遍历 类的继承 for ( ; cls; cls = cls->superclass) { ivar_t *ivar = getIvar(cls, name); if (ivar) { if (memberOf) *memberOf = cls; return ivar; } } return nil; } static ivar_t *getIvar(Class cls, const char *name) { runtimeLock.assertLocked(); const ivar_list_t *ivars; assert(cls->isRealized()); if ((ivars = cls->data()->ro->ivars)) { for (auto& ivar : *ivars) { if (!ivar.offset) continue; // anonymous bitfield // 根据 name 来比较 // ivar.name may be nil for anonymous bitfields etc. if (ivar.name && 0 == strcmp(name, ivar.name)) { return &ivar; } } } return nil; } add variable class_addIvar 只能在 objc_allocateClassPair 和 objc_registerClassPair 之间调用，已经存在的类不支持添加 ivar。所以 ivar 存储在 class_ro_t 。 // object api void object_setIvar(id obj, Ivar ivar, id value); id object_getIvar(id obj, Ivar ivar); Ivar object_setInstanceVariable(id obj, const char *name, void *value); Ivar object_getInstanceVariable(id obj, const char *name, void * _Nullable *outValue); 源码实现 // 实际调用了 object_setIvar Ivar object_setInstanceVariable(id obj, const char *name, void *value) { Ivar ivar = nil; if (obj && name && !obj->isTaggedPointer()) { if ((ivar = class_getInstanceVariable(obj->ISA(), name))) { object_setIvar(obj, ivar, (id)value); } } return ivar; } // 实际调用了 object_getIvar Ivar object_getInstanceVariable(id obj, const char *name, void **value) { if (obj && name && !obj->isTaggedPointer()) { Ivar ivar; if ((ivar = class_getInstanceVariable(obj->ISA(), name))) { if (value) *value = (void *)object_getIvar(obj, ivar); return ivar; } } if (value) *value = nil; return nil; } // 读取 ivar 的 value id object_getIvar(id obj, Ivar ivar) { if (obj && ivar && !obj->isTaggedPointer()) { Class cls = obj->ISA(); ptrdiff_t ivar_offset = ivar_getOffset(ivar); if (_class_usesAutomaticRetainRelease(cls)) { // arc 中的 weak var 需要从 // for ARR, layout strings are relative to the instance start. uint32_t instanceStart = _class_getInstanceStart(cls); const uint8_t *weak_layout = class_getWeakIvarLayout(cls); if (weak_layout && is_scanned_offset(ivar_offset - instanceStart, weak_layout)) { // use the weak system to read this variable. id *location = (id *)((char *)obj + ivar_offset); return objc_loadWeak(location); } } // mrc 或 arc中的strong 根据 起始偏移量 + offset，获取到内存地址，返回 id* 的指针 id *idx = (id *)((char *)obj + ivar_offset); return *idx; } return nil; } // 给 ivar 赋值 void object_setIvar(id obj, Ivar ivar, id value) { if (obj && ivar && !obj->isTaggedPointer()) { Class cls = _ivar_getClass(obj->ISA(), ivar); ptrdiff_t ivar_offset = ivar_getOffset(ivar); id *location = (id *)((char *)obj + ivar_offset); // if this ivar is a member of an ARR compiled class, then issue the correct barrier according to the layout. if (_class_usesAutomaticRetainRelease(cls)) { // for ARR, layout strings are relative to the instance start. uint32_t instanceStart = _class_getInstanceStart(cls); // weak 赋值 const uint8_t *weak_layout = class_getWeakIvarLayout(cls); if (weak_layout && is_scanned_offset(ivar_offset - instanceStart, weak_layout)) { // use the weak system to write to this variable. objc_storeWeak(location, value); return; } // strong 赋值，本质也是 *location = value; const uint8_t *strong_layout = class_getIvarLayout(cls); if (strong_layout && is_scanned_offset(ivar_offset - instanceStart, strong_layout)) { objc_storeStrong(location, value); return; } } // mrc 直接赋值 *location = value; } } strong 下，给 ivar 赋值 void objc_storeStrong(id *location, id obj) { id prev = *location; if (obj == prev) { return; } objc_retain(obj); *location = obj; objc_release(prev); } arc 下，weak 的 取值、赋值 是特别处理的 get value id objc_loadWeak(id *location) { if (!*location) return nil; return objc_autorelease(objc_loadWeakRetained(location)); } // 从 保存 weak 的 hashTable 中找到真实的值 id objc_loadWeakRetained(id *location) { id result; SideTable *table; retry: result = *location; if (!result) return nil; table = &SideTables()[result]; table->lock(); if (*location != result) { table->unlock(); goto retry; } result = weak_read_no_lock(&table->weak_table, location); table->unlock(); return result; } "},"oc/runtime/api/category.html":{"url":"oc/runtime/api/category.html","title":"category","keywords":"","body":"1 https://bestswifter.com/runtime-category/ "},"oc/runtime/api/protocol.html":{"url":"oc/runtime/api/protocol.html","title":"protocol","keywords":"","body":"概述 typedef uintptr_t protocol_ref_t; // protocol_t *, but unremapped // 存放的是 protocol_ref_t struct protocol_list_t class protocol_array_t : public list_array_tt { } objc_getProtocol Returns a specified protocol. objc_copyProtocolList Returns an array of all the protocols known to the runtime. objc_allocateProtocol Creates a new protocol instance. objc_registerProtocol Registers a newly created protocol with the Objective-C runtime. protocol_addMethodDescription Adds a method to a protocol. protocol_addProtocol Adds a registered protocol to another protocol that is under construction. protocol_addProperty Adds a property to a protocol that is under construction. protocol_getName Returns a the name of a protocol. protocol_isEqual Returns a Boolean value that indicates whether two protocols are equal. protocol_copyMethodDescriptionList Returns an array of method descriptions of methods meeting a given specification for a given protocol. protocol_getMethodDescription Returns a method description structure for a specified method of a given protocol. protocol_copyPropertyList Returns an array of the properties declared by a protocol. protocol_getProperty Returns the specified property of a given protocol. protocol_copyProtocolList Returns an array of the protocols adopted by a protocol. protocol_conformsToProtocol Returns a Boolean value that indicates whether one protocol conforms to another protocol. "},"oc/runtime/api/property.html":{"url":"oc/runtime/api/property.html","title":"property","keywords":"","body":"概要 // property_t 等价于 typedef struct property_t *objc_property_t; struct property_t { const char *name; const char *attributes; }; struct objc_property_attribute_t { const char *name; /** { }; // 二维数组存储 [[property_t], [property_t, property_t]] class property_array_t : public list_array_tt { }; // 注意：property_t 存储在 class_rw_t 中 struct class_rw_t { // ... property_array_t properties; // ... }; struct class_ro_t { property_list_t *baseProperties; } runtime api const char * property_getName(objc_property_t property); // 示例: T@\"NSString\",&,N,V_lastName const char * property_getAttributes(objc_property_t property); char * property_copyAttributeValue(objc_property_t property, const char *attributeName); objc_property_attribute_t * property_copyAttributeList(objc_property_t property, unsigned int *outCount); class runtime api objc_property_t class_getProperty(Class cls, const char *name); objc_property_t _Nonnull * class_copyPropertyList(Class cls, unsigned int *outCount); BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount); void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount); 源码解析 get property objc_property_t class_getProperty(Class cls, const char *name) { if (!cls || !name) return nil; rwlock_reader_t lock(runtimeLock); // 递归循环，从 class_rw_t 持有的 property_array_t 中遍历查找 property_t for ( ; cls; cls = cls->superclass) { for (auto& prop : cls->data()->properties) { if (0 == strcmp(name, prop.name)) { return (objc_property_t)&prop; } } } return nil; } add & replace property BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attrs, unsigned int n) { return _class_addProperty(cls, name, attrs, n, NO); } void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attrs, unsigned int n) { _class_addProperty(cls, name, attrs, n, YES); } // add 和 replace 都会调用这里 static bool _class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attrs, unsigned int count, bool replace) { if (!cls) return NO; if (!name) return NO; property_t *prop = class_getProperty(cls, name); if (prop && !replace) { // 如果已存在，则 add 会失败 already exists, refuse to add return NO; } else if (prop) { // 如果已存在，则会 replace 掉 property_t 的 attris replace existing rwlock_writer_t lock(runtimeLock); try_free(prop->attributes); prop->attributes = copyPropertyAttributeString(attrs, count); return YES; } else { rwlock_writer_t lock(runtimeLock); assert(cls->isRealized()); // 不存在，则创建一个新的 property_list_t， 把 property_t 添加到 property_list_t， // 然后把 property_list_t，添加到 property_array_t 的最前端 property_list_t *proplist = (property_list_t *) malloc(sizeof(*proplist)); proplist->count = 1; proplist->entsizeAndFlags = sizeof(proplist->first); proplist->first.name = strdup(name); proplist->first.attributes = copyPropertyAttributeString(attrs, count); cls->data()->properties.attachLists(&proplist, 1); return YES; } } 何时会加载 property ObjC setup void _objc_init(void) └──const char *map_2_images(...) └──const char *map_images_nolock(...) └──void _read_images(header_info **hList, uint32_t hCount) void _read_images(header_info **hList, uint32_t hCount) { // ... header_info *hi; if (!noClassesRemapped()) { // 遍历所有 image ，读取其中的 class for (EACH_HEADER) { // 对应 image 中的 \"__objc_classrefs\" 部分 Class *classrefs = _getObjc2ClassRefs(hi, &count); for (i = 0; i "},"oc/runtime/api/selector.html":{"url":"oc/runtime/api/selector.html","title":"selector","keywords":"","body":"Selector runtime api sel_getName Returns the name of the method specified by a given selector. sel_registerName Registers a method with the Objective-C runtime system, maps the method name to a selector, and returns the selector value. sel_getUid Registers a method name with the Objective-C runtime system. sel_isEqual Returns a Boolean value that indicates whether two selectors are equal. @selector 原理 结论： ObjC setup 时创建了一 hastable，key 为 (char *)name， value 为 SEL ，一个内存地址(intptr_t)。 在使用 @selector() 时会从这个表中根据名字查找对应的 SEL 。如果没有找到，则会生成一个 SEL 并添加到表中 在编译期间会扫描全部的头文件和实现文件将其中的方法以及使用 @selector() 生成的选择子加入到选择子表中 每个 SEL 实际是一个 内存地址 intptr_t。而该地址指向的是 c 的字符串 (char *) 源码实现 typedef intptr_t SEL // 两个指针知否指向同一个内存地址 BOOL sel_isEqual(SEL lhs, SEL rhs) { return bool(lhs == rhs); } // 直接读取 char* 为名字 const char *sel_getName(SEL sel) { if (!sel) return \"\"; return (const char *)(const void*)sel; } // 注册selector SEL sel_registerName(const char *name) { return __sel_registerName(name, 1, 1); // YES lock, YES copy } static SEL __sel_registerName(const char *name, int lock, int copy) { SEL result = 0; if (lock) selLock.assertUnlocked(); else selLock.assertWriting(); if (!name) return (SEL)0; // 多加了一层 cache 。 enable dyld shared cache optimizations result = search_builtins(name); if (result) return result; if (lock) selLock.read(); // 从 hashtable 中读取值 if (namedSelectors) { result = (SEL)NXMapGet(namedSelectors, name); } if (lock) selLock.unlockRead(); if (result) return result; // No match. Insert. if (lock) selLock.write(); // 第一次，要创建 hashtable if (!namedSelectors) { namedSelectors = NXCreateMapTable(NXStrValueMapPrototype, (unsigned)SelrefCount); } if (lock) { // Rescan in case it was added while we dropped the lock result = (SEL)NXMapGet(namedSelectors, name); } // 在 hashtabe 中增加键值对 key 为 char*， value 为 SEL if (!result) { result = sel_alloc(name, copy); // fixme choose a better container (hash not map for starters) NXMapInsert(namedSelectors, sel_getName(result), result); } if (lock) selLock.unlockWrite(); return result; } /// 初次初始化，调用了 sel_registerNameNoLock SEL sel_registerNameNoLock(const char *name, bool copy) { return __sel_registerName(name, 0, copy); // NO lock, maybe copy } 何时会添加 selector ObjC init 时，初始化基本的 selector // 首次 初始化 selector table 并且把上面读取的 SEL 注册到 table 中 // Initialize selector tables and register selectors used internally sel_init(wantsGC, selrefCount); 中注册了部分 SEL void sel_init(bool wantsGC, size_t selrefCount) { #define s(x) SEL_##x = sel_registerNameNoLock(#x, NO) #define t(x,y) SEL_##y = sel_registerNameNoLock(#x, NO) sel_lock(); s(load); s(initialize); t(resolveInstanceMethod:, resolveInstanceMethod); t(resolveClassMethod:, resolveClassMethod); t(.cxx_construct, cxx_construct); t(.cxx_destruct, cxx_destruct); s(retain); s(release); s(autorelease); s(retainCount); s(alloc); t(allocWithZone:, allocWithZone); s(dealloc); s(copy); s(new); s(finalize); t(forwardInvocation:, forwardInvocation); t(_tryRetain, tryRetain); t(_isDeallocating, isDeallocating); s(retainWeakReference); s(allowsWeakReference); sel_unlock(); #undef s #undef t } 运行时 调用 @selector 或 NSSelectorFromString() 时，如果在 hashtabel 中不存在 则会新增到 hashtable 中 "},"oc/runtime/api/associatedObject.html":{"url":"oc/runtime/api/associatedObject.html","title":"associatedObject","keywords":"","body":"Associative References objc_setAssociatedObject Sets an associated value for a given object using a given key and association policy. objc_getAssociatedObject Returns the value associated with a given object for a given key. objc_removeAssociatedObjects Removes all associations for a given object. "},"oc/runtime/api/objc_cache.html":{"url":"oc/runtime/api/objc_cache.html","title":"objc_cache","keywords":"","body":"objc_cache 使用 用于缓存 class 的消息 struct objc_class { struct objc_cache cache; } 实现 struct objc_cache { unsigned int mask; //指定分配缓存bucket的总数。total = mask + 1 runtime使用这个字段确定线性查找数组的索引位置 unsigned int occupied; //实际占用缓存bucket总数 Method buckets[1]; //指向Method数据结构指针的数组，这个数组的总数不能超过mask+1，但是指针是可能为空的，这就表示缓存bucket没有被占用，数组会随着时间增长。 }; "},"oc/runtime/api/sendMsg.html":{"url":"oc/runtime/api/sendMsg.html","title":"sendMessage","keywords":"","body":"Send Message objc_msgSend Sends a message with a simple return value to an instance of a class. objc_msgSend_fpret Sends a message with a floating-point return value to an instance of a class. objc_msgSend_stret Sends a message with a data-structure return value to an instance of a class. objc_msgSendSuper Sends a message with a simple return value to the superclass of an instance of a class. objc_msgSendSuper_stret Sends a message with a data-structure return value to the superclass of an instance of a class. 消息转发 分 3 个步骤： 从当前类的缓存中查找 imp 从方法列表查找消息，从父类递归查找 消息转发 "},"oc/runtime/api/other.html":{"url":"oc/runtime/api/other.html","title":"其他api","keywords":"","body":"其他 api Using Objective-C Language Features objc_enumerationMutation Inserted by the compiler when a mutation is detected during a foreach iteration. objc_setEnumerationMutationHandler Sets the current mutation handler. imp_implementationWithBlock Creates a pointer to a function that calls the specified block when the method is called. imp_getBlock Returns the block associated with an IMP that was created using imp_implementationWithBlock. imp_removeBlock Disassociates a block from an IMP that was created using imp_implementationWithBlock, and releases the copy of the block that was created. objc_loadWeak Loads the object referenced by a weak pointer and returns it. objc_storeWeak Stores a new value in a __weak variable. "},"oc/keyword/":{"url":"oc/keyword/","title":"ObjC其他","keywords":"","body":"keyword "},"oc/keyword/NSObject.html":{"url":"oc/keyword/NSObject.html","title":"NSObject","keywords":"","body":"NSObject Protocol NSObject @protocol NSObject /// 发消息 - (id)performSelector:(SEL)aSelector; - (id)performSelector:(SEL)aSelector withObject:(id)object; - (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2; - (BOOL)respondsToSelector:(SEL)aSelector; /// 是否为 Cls 类型，也可以为子类 - (BOOL)isKindOfClass:(Class)aClass; /// 是否为 Cls 类型， - (BOOL)isMemberOfClass:(Class)aClass; - (BOOL)conformsToProtocol:(Protocol *)aProtocol; /// what？ - (BOOL)isProxy; - (BOOL)isEqual:(id)object; @property (readonly) NSUInteger hash; @property (readonly) Class superclass; - (Class)class; - (instancetype)self; @end Class NSObject @interface NSObject { Class isa; } + (void)load; + (void)initialize; + (instancetype)new; + (instancetype)alloc; /// zone 的作用 + (instancetype)allocWithZone:(NSZone)zone; - (void)init; - (void)dealloc - (id)copy; - (id)mutableCopy; + (BOOL)isSubclassOfClass:(Class)aClass; + (BOOL)instancesRespondToSelector:(SEL)aSelector; + (BOOL)conformsToProtocol:(Protocol *)protocol; - (IMP)methodForSelector:(SEL)aSelector; + (IMP)instanceMethodForSelector:(SEL)aSelector; - (void)doesNotRecognizeSelector:(SEL)aSelector; // 动态增加 IMP + (BOOL)resolveClassMethod:(SEL)sel __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0); + (BOOL)resolveInstanceMethod:(SEL)sel __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0); // 消息转发 - (id)forwardingTargetForSelector:(SEL)aSelector; - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector; - (void)forwardInvocation:(NSInvocation *)anInvocation; 注意事项： "},"oc/keyword/atomic.html":{"url":"oc/keyword/atomic.html","title":"atomic","keywords":"","body":"原子性 Atomic 原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败。即使多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。 int a = 10; // 是原子操作。只有赋值一个操作 int b = a; // 不是原子操作。包含两个操作：读取a；给b赋值 a++; // 不是原子操作，包含三个操作：读取a；进行 a + 1 操作；给a赋值 非原子性操作，在多线程操作中是不安全的。 线程不安全就是多线程环境下，执行可能不会得到正确的结果。 property的修饰符： atomic 与 nonatomic 实际是 对 set 和 get 方法的调整 如果是 atomic 则使用 spinlock_t 来加锁 static setProperty(...) { if (atomic) { spinlock_t& slotlock = PropertyLocks[slot]; slotlock.lock(); oldValue = *slot; *slot = newValue; slotlock.unlock(); } else { oldValue = *slot; *slot = newValue; } } static id objc_getProperty(...) { id *slot = (id*) ((char*)self + offset); if (!atomic) return *slot; // nonatomic // Atomic retain release world spinlock_t& slotlock = PropertyLocks[slot]; slotlock.lock(); id value = objc_retain(*slot); slotlock.unlock(); return value; } "},"oc/keyword/synchronized.html":{"url":"oc/keyword/synchronized.html","title":"synchronized","keywords":"","body":"@synchronized ask StripMap struct SyncList { spinlock_t lock; SyncData *data; } // 一个 obj 对应一个 SyncData 对象，对应一个 递归锁 struct SyncData { recusive_mutex_t mutex; SyncData *next; DisguisedPtr object; } 具体使用： NSObject* obj = [NSObject new]; @synchronized (obj) { // } lock底层存储： // 全局哈希表 会有64个SyncList对象，会根据obj的内存地址计算出数据存储到某个SyncList中(全局哈希表 会多线程使用，处理数据的时候需要加锁。每个SyncList对象内部有自己的锁。 最多可以有64个读写同时发生)。 StripedMap // 一个链表 struct SyncList { SyncData *data; spinlock_t lock; }; //每个obj对应一个SyncData对象，封装了mutex struct SyncData { struct SyncData* nextData; DisguisedPtr object; int32_t threadCount; // number of THREADS using this block recursive_mutex_t mutex; } 详细参考： http://blog.quding0308.com/objc,/runtime/2018/09/11/ObjC%E4%B8%AD@synchronized%E7%9A%84%E5%AE%9E%E7%8E%B0.html 总结： 底层使用 recursive_mutex_t 做锁操作 加锁、解锁 synchronized 使用obj的内存地址作为key，通过hash map对应的一个系统维护的递归锁 不要使用self作为obj，而是应该声明一个私有的obj来作为key，self 颗粒度太大。@synchronized如果控制好精度，也不会很慢。精度控制 就是 对obj的使用（如果所有的 @synchronized都使用一个obj，则就会很慢了）。不同数据应该使用不同的obj来控制在最细的粒度 @synchronized(nil) 不起任何作用。当obj的生命周期结束了，同步代码也就失效 "},"oc/keyword/arc.html":{"url":"oc/keyword/arc.html","title":"arc","keywords":"","body":"ARC Runtime Support id objc_autorelease(id value); void objc_autoreleasePoolPop(void *pool); void *objc_autoreleasePoolPush(void); id objc_autoreleaseReturnValue(id value); void objc_copyWeak(id *dest, id *src); void objc_destroyWeak(id *object); id objc_initWeak(id *object, id value); id objc_loadWeak(id *object); id objc_loadWeakRetained(id *object); void objc_moveWeak(id *dest, id *src); void objc_release(id value); id objc_retain(id value); id objc_retainAutorelease(id value); id objc_retainAutoreleaseReturnValue(id value); id objc_retainAutoreleasedReturnValue(id value); id objc_retainBlock(id value); id objc_storeStrong(id *object, id value); id objc_storeWeak(id *object, id value); 引用计数 下一篇文章 参考： https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-optimization-precise "},"oc/keyword/refCount.html":{"url":"oc/keyword/refCount.html","title":"referecne count","keywords":"","body":"ARC的引用计数的存储有3种方式 TaggedPointer isa指针 散列表 TaggedPointer TaggedPointer专门用来存储小的对象（例如 NSNumber、NSDate、小字符串），TaggedPointer指针的地址不再仅仅是地址了，而是存储了真正的值。它的内存并不存储在堆中，也不需要调用malloc 和 free 在64位机器上，并且是iPhone平台支持TaggedPointer 官方描述：objc-runtime-new.mm中 /*********************************************************************** * Tagged pointer objects. * * Tagged pointer objects store the class and the object value in the * object pointer; the \"pointer\" does not actually point to anything. * * Tagged pointer objects currently use this representation: * (LSB) // 最低有效位 Least Significant Bit * 1 bit set if tagged, clear if ordinary object pointer * 3 bits tag index * 60 bits payload * (MSB) // 最高有效位 Most Significant Bit * The tag index defines the object's class. * The payload format is defined by the object's class. * * This representation is subject to change. Representation-agnostic SPI is: * objc-internal.h for class implementers. * objc-gdb.h for debuggers. **********************************************************************/ 由于不需要再堆中存储，也不需要内存管理。所以在内存管理中 retain和release都不追做任何操作。retainCount会返回自己的地址。 id objc_retain(id obj) { if (obj->isTaggedPointer()) return obj; } void objc_release(id obj) { if (obj->isTaggedPointer()) return; } inline uintptr_t objc_object::rootRetainCount() { if (isTaggedPointer()) return (uintptr_t)this; } 对于TaggedPointer对象，weak引用也不需要做额外管理（不需要再全局hash表中做记录） id weak_register_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id, bool crashIfDeallocating) { objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; if (!referent || referent->isTaggedPointer()) return referent_id; } id weak_read_no_lock(weak_table_t *weak_table, id *referrer_id) { objc_object **referrer = (objc_object **)referrer_id; objc_object *referent = *referrer; if (referent->isTaggedPointer()) return (id)referent; } is-a指针存储引用计数 用 64 bit 存储一个内存地址显然是种浪费，毕竟很少有那么大内存的设备。于是可以优化存储方案，用一部分额外空间存储其他内容。isa 指针第一位为 1 即表示使用优化的 isa 指针。 在 64 位环境下，优化的 isa 指针并不是就一定会存储引用计数，毕竟用 19bit （iOS 系统）保存引用计数不一定够。需要注意的是这 19 位保存的是引用计数的值减一。has_sidetable_rc 的值如果为 1，那么引用计数会存储在一个叫 SideTable 的类的属性中，后面会详细讲。 只有在64位的真机上才会使用下面的结构体： union isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits; // extra_rc must be the MSB-most field (so it matches carry/overflow flags) // indexed must be the LSB (fixme or get rid of it) // shiftcls must occupy the same bits that a real class pointer would // bits + RC_ONE is equivalent to extra_rc + 1 // RC_HALF is the high bit of extra_rc (i.e. half of its range) // future expansion: // uintptr_t fast_rr : 1; // no r/r overrides // uintptr_t lock : 2; // lock for atomic property, @synch // uintptr_t extraBytes : 1; // allocated with extra bytes # define ISA_MASK 0x0000000ffffffff8ULL # define ISA_MAGIC_MASK 0x000003f000000001ULL # define ISA_MAGIC_VALUE 0x000001a000000001ULL struct { // 0表示普通isa指针，1表示使用优化，存储引用计数 uintptr_t indexed : 1; // 是否包含associated object uintptr_t has_assoc : 1; // uintptr_t has_cxx_dtor : 1; // 类的指针 uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000 // unknow uintptr_t magic : 6; // 是否有weak对象 uintptr_t weakly_referenced : 1; // 是否在析构 uintptr_t deallocating : 1; // 引用计数值过大，还需要存储在sidetable中 uintptr_t has_sidetable_rc : 1; // 存储引用计数值减1后的结果 uintptr_t extra_rc : 19; # define RC_ONE (1ULL使用is-a指针记录引用计数时的源码 （代码有修改，源码在NSObject.mm中找） id objc_object::rootRetain(bool tryRetain, bool handleOverflow) { isa_t oldisa; isa_t newisa; transcribeToSideTable = false; oldisa = LoadExclusive(&isa.bits); newisa = oldisa; if (newisa.indexed) { uintptr_t carry; newisa.bits = addc(newisa.bits, RC_ONE, 0, &carry); // 给extra_rc++ // extra_rc 无法储存了， if (carry) { // newisa.extra_rc++ overflowed if (!handleOverflow) return rootRetain_overflow(tryRetain); // Leave half of the retain counts inline and // prepare to copy the other half to the side table. if (!tryRetain && !sideTableLocked) sidetable_lock(); sideTableLocked = true; transcribeToSideTable = true; newisa.extra_rc = RC_HALF; newisa.has_sidetable_rc = true; // Copy the other half of the retain counts to the side table. sidetable_addExtraRC_nolock(RC_HALF); if (!tryRetain && sideTableLocked) sidetable_unlock(); return (id)this; } } } inline uintptr_t objc_object::rootRetainCount() { sidetable_lock(); isa_t bits = LoadExclusive(&isa.bits); if (bits.indexed) { uintptr_t rc = 1 + bits.extra_rc; if (bits.has_sidetable_rc) { // 引用计数值过大，还需要存储在sidetable中 rc += sidetable_getExtraRC_nolock(); } sidetable_unlock(); return rc; } } 散列表存储引用计数 散列表来存储引用计数具体是用 DenseMap 类来实现 typedef objc::DenseMap,size_t,true> RefcountMap; key 键的类型为 DisguisedPtr，DisguisedPtr 类是对 objc_object * 指针及其一些操作进行的封装，其内容可以理解为对象的内存地址 value 值的类型为 unsigned long。这里保存的值也是等于引用计数减一 更详细 在 weak 那一篇文章中 参考 http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/ "},"oc/keyword/weak.html":{"url":"oc/keyword/weak.html","title":"weak","keywords":"","body":"weak ask StripMap // 64 个 SideTable { RefcountMap refcnts; weak_table_t weak_table; } weak_table_t { weak_entry_t *weak_entries; } 总结 对于TaggedPointer对象，weak引用也不需要做额外管理（不需要再全局hash表中做记录） 底层存储 StripedMap 包含64个 sidetable 对象，根据 对象的地址 找到某个sidetable对象 // SideTables对象，以StripedMap实现，包含64个SideTable对象 static StripedMap SideTables() SideTable SideTable ，用于管理引用计数表(RefcountMap)和 weak 表 (weak_table_t)，并使用 spinlock_lock 自旋锁来防止操作表结构时可能的竞态条件。 SideTables/RefcountMap/weak_table_t的使用\b struct SideTable { // 保存引用计数的散列表 RefcountMap refcnts; //保存 weak 引用的全局散列表 weak_table_t weak_table; // 保证原子操作的自选锁 spinlock_t slock; // 锁保证 atomic }; struct weak_table_t { weak_entry_t *weak_entries; // 数组 存储了指向某个对象的所有弱引用的变量指针 size_t num_entries; uintptr_t mask; uintptr_t max_hash_displacement; }; struct weak_entry_t { DisguisedPtr referent; // 某个对象的指针 weak_referrer_t *referrers; // 数组 对这个对象的弱引用的变量地址存在这里 }; weak的实现 id objc_initWeak(id *object, id value) { if (!newObj) { *location = nil; return nil; } return storeWeak (location, (objc_object*)newObj); } id objc_loadWeak(id _Nullable *location) { if (!*location) return nil; return objc_autorelease(objc_loadWeakRetained(location)); } id objc_loadWeakRetained(id *object) { id result; SideTable *table; retry: result = *location; if (!result) return nil; table = &SideTables()[result]; table->lock(); if (*location != result) { table->unlock(); goto retry; } result = weak_read_no_lock(&table->weak_table, location); table->unlock(); return result; } id objc_storeWeak(id _Nullable *location, id obj) { return storeWeak(location, (objc_object *)obj) } void objc_copyWeak(id *dest, id *src) { id obj = objc_loadWeakRetained(src); objc_initWeak(dst, obj); objc_release(obj); } void objc_destroyWeak(id *object) { objc_storeWeak(object, nil); } strong 实现 //hash table key 为obj，value 为 引用计数 typedef objc::DenseMap,size_t,true> RefcountMap; "},"oc/keyword/autoreleasepool.html":{"url":"oc/keyword/autoreleasepool.html","title":"autoreleasepool","keywords":"","body":"AutoreleasePool App 中有多少个 AutoreleasePool ? AutoreleasePool 可以嵌套吗？ 一个对象可以放到一个 pool 中多次吗？ AutoreleasePool 与 多线程 有什么关系？ 有什么用？ 当调用 [obj autorelease] 时，不会立刻释放 obj ，而是会把 obj 保存到 AutoreleasePool 中，当 AutoreleasePool pop 时，统一调用 [obj release] 方便对象的内存管理。 可以延长 obj 的生命周期。 自己的代码 自己在代码中写 AutoreleasePool 可以减小内存峰值。 程序中循环遍历时有大量临时变量的时候最好手动创建。 参考：https://developer.apple.com/documentation/foundation/nsautoreleasepool?language=objc 如何使用 主线程的每个Runloop周期会创建一个新的 AutoreleasePool App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池； Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 main runloop /* observers = ( // kCFRunLoopEntry \"{valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = (0x23eb9dec0), context = {type = mutable-small, count = 1, values = (\\n\\t0 : \\n)}}\", // kCFRunLoopBeforeWaiting \"{valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = (0x23e7b2f28), context = }\", // kCFRunLoopBeforeWaiting || kCFRunLoopExit \"{valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = (0x23ebcd77c), context = }\", \"{valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = (0x215f94cd4), context = }\", \"{valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = (0x23ebcd7fc), context = }\", \"{valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = (0x23eb9dec0), context = {type = mutable-small, count = 1, values = (\\n\\t0 : \\n)}}\" ), */ /* typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { 1 kCFRunLoopEntry = (1UL 使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool： [array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) { // 这里被一个局部@autoreleasepool包围着 }]; 当然，在普通for循环和for in循环中没有，所以，还是新版的block版本枚举器更加方便。for循环中遍历产生大量autorelease变量时，就需要手加局部AutoreleasePool 自己的代码中使用 @autoreleasepool { // } 实现原理 编译如何处理 代码： @autoreleasepool { int a = 1; int b = a; } 命令： 生成汇编 clang -S -fobjc-arc main.m -o main.s 生成目标文件 clang -fmodules -c main.m -o main.o 编译后的代码： void* pool = objc_autoreleasePoolPush(); // do sth objc_autoreleasePoolPop(pool); 更进一步： void *objc_autoreleasePoolPush(void) { return AutoreleasePoolPage::push(); } void objc_autoreleasePoolPop(void *pool) { AutoreleasePoolPage::pop(pool); } 原理： - 调用 AutoreleasePoolPage::push() 会返回 一个哨兵对象的地址，这个地址就是 一个 pool 的开端 - 当对象调用 autorelease 方法时，会将 引用计数+1 的对象加入 AutoreleasePoolPage 的栈中 - 调用 AutoreleasePoolPage::pop 方法会向栈中的对象发送 release 消息 运行时如何处理 AutoreleasePoolPage class AutoreleasePoolPage { static pthread_key_t const key = AUTORELEASE_POOL_KEY; // 唯一标识 magic_t const magic; id *next; // 指向最新添加的 autoreleased 对象的下一个位置，初始化时指向 begin() pthread_t const thread; // 当前page所在的线程 AutoreleasePoolPage * const parent; // 双向链表parent AutoreleasePoolPage *child; // 双向链表child uint32_t const depth; uint32_t hiwat; static size_t const SIZE = PAGE_MAX_SIZE; // 4096 bytes static size_t const COUNT = SIZE / sizeof(id); // 指针数量 // method static inline AutoreleasePoolPage *hotPage(); static inline AutoreleasePoolPage *coldPage(); static inline void *push(); static inline id *autoreleaseFast(id obj); id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page); static inline void pop(void *token); }; #define POOL_SENTINEL nil // 哨兵 从编译到运行时 static id objc_retainAutoreleaseAndReturn(id obj) { return objc_retainAutorelease(obj); } id objc_retainAutorelease(id obj) { return objc_autorelease(objc_retain(obj)); } id objc_autoreleaseReturnValue(id obj) { return objc_autorelease(obj); } id objc_autorelease(id obj) { if (!obj) return obj; if (obj->isTaggedPointer()) return obj; return obj->autorelease(); } objc_object::autorelease() { // UseGC is allowed here, but requires hasCustomRR. assert(!UseGC || ISA()->hasCustomRR()); if (isTaggedPointer()) return (id)this; if (! ISA()->hasCustomRR()) return rootAutorelease(); return ((id(*)(objc_object *, SEL))objc_msgSend)(this, SEL_autorelease); } // NSObject.mm static inline id autorelease(id obj) { assert(obj); assert(!obj->isTaggedPointer()); id *dest __unused = autoreleaseFast(obj); // 调用 assert(!dest || *dest == obj); return obj; } AutoreleasePoolPage::push() static inline void *push() { return autoreleaseFast(POOL_SENTINEL); // POOL_SENTINEL为哨兵 } /* 有 hotPage 并且 page 不满 调用 page->add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中 有 hotPage 并且当前 page 已满，调用 autoreleaseFullPage 1. 初始化一个新的页(如果有child，直接复用) 2.调用 page->add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中 3.设置新的hotPage 无 hotPage，autoreleaseNoPage 1.调用 autoreleaseNoPage 创建一个 page 2.调用 page->add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中 3.设置hotPage */ static inline id *autoreleaseFast(id obj) { AutoreleasePoolPage *page = hotPage(); if (page && !page->full()) { return page->add(obj); } else if (page) { return autoreleaseFullPage(obj, page); } else { return autoreleaseNoPage(obj); } } // Check per-thread single page static inline AutoreleasePoolPage *hotPage() { AutoreleasePoolPage *result = (AutoreleasePoolPage *) tls_get_direct(key); if (result) result->fastcheck(); return result; } // 返回 obj 的内存地址 id *add(id obj) { assert(!full()); unprotect(); id *ret = next; *next++ = obj; protect(); return ret; } // hotPage已满 static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) { do { if (page->child) page = page->child; else page = new AutoreleasePoolPage(page); } while (page->full()); setHotPage(page); return page->add(obj); } // 没有hotPage static id *autoreleaseNoPage(id obj) { AutoreleasePoolPage *page = new AutoreleasePoolPage(nil); setHotPage(page); if (obj != POOL_SENTINEL) { page->add(POOL_SENTINEL); } return page->add(obj); } static inline void setHotPage(AutoreleasePoolPage *page) { if (page) page->fastcheck(); tls_set_direct(key, (void *)page); } AutoreleasePoolPage::pop(ctxt); 遍历双向链表中的所有page对象，对page中存储的obj 出栈 分别做release操作 /* 1. page 中的 [obj release] 2. 删除 page */ static inline void pop(void *token) { AutoreleasePoolPage *page = pageForPointer(token); id *stop = (id *)token; // release page->releaseUntil(stop); // delete child page if (page->child) { if (page->lessThanHalfFull()) { page->child->kill(); } else if (page->child->child) { page->child->child->kill(); } } } void releaseUntil(id *stop) { // Not recursive: we don't want to blow out the stack // if a thread accumulates a stupendous amount of garbage while (this->next != stop) { // Restart from hotPage() every time, in case -release // autoreleased more objects AutoreleasePoolPage *page = hotPage(); // fixme I think this `while` can be `if`, but I can't prove it while (page->empty()) { // 如果为空 则 page = page->parent; setHotPage(page); } page->unprotect(); id obj = *--page->next; memset((void*)page->next, SCRIBBLE, sizeof(*page->next)); page->protect(); if (obj != POOL_SENTINEL) { objc_release(obj); } } setHotPage(this); } void kill() { // Not recursive: we don't want to blow out the stack // if a thread accumulates a stupendous amount of garbage AutoreleasePoolPage *page = this; while (page->child) page = page->child; // 找到最后一个 page AutoreleasePoolPage *deathptr; do { deathptr = page; page = page->parent; if (page) { page->unprotect(); page->child = nil; page->protect(); } delete deathptr; } while (deathptr != this); } NSOject static inline id autorelease(id obj) { assert(obj); assert(!obj->isTaggedPointer()); id *dest __unused = autoreleaseFast(obj); // 此处会把 obj push 到 page 中 assert(!dest || *dest == obj); return obj; } 整个App的pool 底层都使用一个双向链表实现 自动释放池是由 AutoreleasePoolPage 以双向链表的方式实现的。 每一个自动释放池都是由一系列的 AutoreleasePoolPage 组成，并且每一个 AutoreleasePoolPage 的大小都是 4096 字节。 App中的所有自动释放池都存储在同一个双向链表中，一个自动释放池的开头是 哨兵对象的，存储了一个nil对象。 与多线程的关系？ 主线程中的自动释放池是自动创建的。实际上，我们常用的多线程管理方式(GCD, NSOprationQueue, NSThread)也都会帮我们创建对应的AutoreleasePool (当第一次 push obj 的时候创建) 。在线程结束时，执行 pop 。 具体参考：https://stackoverflow.com/questions/24952549/does-nsthread-create-autoreleasepool-automatically-now 注意：如果一个子线程一直在运行，而不会结束时， AutoreleasePool 不会及时的 pop。 /*********************************************************************** Autorelease pool implementation A thread's autorelease pool is a stack of pointers. Each pointer is either an object to release, or POOL_SENTINEL which is an autorelease pool boundary. A pool token is a pointer to the POOL_SENTINEL for that pool. When the pool is popped, every object hotter than the sentinel is released. The stack is divided into a doubly-linked list of pages. Pages are added and deleted as necessary. Thread-local storage points to the hot page, where newly autoreleased objects are stored. **********************************************************************/ BREAKPOINT_FUNCTION(void objc_autoreleaseNoPool(id obj)); TLS-线程局部存储 在 hotPage() 和 setHotPage() 的实现中有两个底层的函数： static pthread_key_t const key = AUTORELEASE_POOL_KEY; // 唯一标识 tls_set_direct(key, (void *)page); AutoreleasePoolPage *result = (AutoreleasePoolPage *)tls_get_direct(key); tls (Thread Local Storage) 线程局部存储，用来将数据与一个正在运行的线程关联起来。 进程中的 全局变量 和 函数内定义的 静态变量(static) 是各线程都可以访问的共享变量。在一个线程内修改，对所有线程生效。 TLS技术的作用：为了避免多个线程同时访存同一全局变量或者静态变量时所导致的冲突，尤其是多个线程同时需要修改这一变量时。为了解决这个问题，可以通过TLS机制，为每一个使用该全局变量的线程都提供一个变量值的副本，每一个线程均可以独立地改变自己的副本，而不会和其它线程的副本冲突。从线程的角度看，就好像每一个线程都完全拥有该变量。而从全局变量的角度上来看，就好像一个全局变量被克隆成了多份副本，而每一份副本都可以被一个线程独立地改变。 参考 https://draveness.me/autoreleasepool https://blog.sunnyxx.com/2014/10/15/behind-autorelease/ "},"oc/keyword/runloop.html":{"url":"oc/keyword/runloop.html","title":"runloop","keywords":"","body":"runloop 一些疑问 RunLoop在系统中所处的角色 RunLoop具体作用是什么？有没有其他类似的机制可以代替角色？ 每个线程都对应一个RunLoop对象吗？ RunLoop 有哪些事件？如何监听？ RunLoop 具体可以设置什么property？分别有什么作用？设置的属性 怎么起作用的？实质是与系统交互的api 实际工作中 有哪些经典实用？卡顿监听？asynckit中的经典实用？autoreleasepool、触摸事件的处理？ mainRunLoop 与 其他RunLoop的区别？有哪些特权？ 具体如何运转？ Runloop 简介 所谓 Runloop 就是 苹果设计的一种 在当前线程，持续调度各种任务 的运行机制。 伪代码： while(alive) { performTask() // 执行任务 call_to_observer() // 回调 通知外部当前处于哪个阶段 sleep() // 休眠 } Runloop 的 mode Runloop 运行时只可能处于一个mode模式(currentMode)，切换mode时需要停止重新运行。一个 mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。 iOS公开提供了两个Mode： UITrackingRunLoopMode NSDefaultRunLoopMode main Runloop 中，这两个 mode 都在 commonModes 中 UITrackingRunLoopMode 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 mode 影响 NSDefaultRunLoopMode 默认Mode，主线程是在这个Mode运行 CommonMode 一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。 每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。 _commonModes存储了标记为common的mode _commonModeItems里存储的是common mode中的Set // 将mode标记为common CFRunLoopAddCommonMode(loop, mode); 实际使用： main runloop中增加一个timer 如果只增加到 kCFRunLoopDefaultMode，则当页面滑动出发 mode：UITrackingRunLoopMode，改timer就无法被触发。此时可以把timer增加到 kCFRunLoopCommonModes，无论kCFRunLoopDefaultMode 或 UITrackingRunLoopMode 都可以触发timer 一个 mode 中可以添加 source、observer、timer Runloop mode1 source0 source1 Observer Timer mode2 source0 source1 Observer Timer Runloop 的 Observer RunLoop可以观察的时间点： typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { kCFRunLoopEntry = (1UL 添加 obsrver CFRunLoopRef loop = CFRunLoopGetMain(); CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(NULL, kCFRunLoopBeforeSources, true, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) { NSLog(@\"observer %lu\", activity); }); CFRunLoopAddObserver(loop, observer, kCFRunLoopCommonModes); Runloop 源码 struct __CFRunLoop { CFMutableSetRef _commonModes; // Set CFMutableSetRef _commonModeItems; // Set CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // Set }; struct __CFRunLoopMode { CFStringRef _name; // Mode Name, 例如 @\"kCFRunLoopDefaultMode\" CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ... }; 底层存储： // 获取RunLoop对象 CFRunLoopRef _CFRunLoopGet0(pthread_t t) { if (pthread_equal(t, kNilPthreadT)) { t = pthread_main_thread_np(); // t == 0 为main thread } __CFLock(&loopsLock); /// __CFRunLoops是一个CFDictionary对象，全局存储RunLoop，key为pthread，value为Runloop if (!__CFRunLoops) { CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &kCFTypeDictionaryValueCallBacks); CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np()); CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop); if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&__CFRunLoops)) { CFRelease(dict); } CFRelease(mainLoop); } CFRunLoopRef newLoop = NULL; // 从全局的Dictionary中取缓存的RunLoop对象 CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); if (!loop) { // 如果没有则新建RunLoop 【从这里可以看出，创建thread时并没有对应的RunLoop，只有主动CFRunLoopGetCurrent才会创建】 newLoop = __CFRunLoopCreate(t); CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop); loop = newLoop; } __CFUnlock(&loopsLock); // don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it if (newLoop) { CFRelease(newLoop); } if (pthread_equal(t, pthread_self())) { _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL); if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) { _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop); } } return loop; } // 获取 main Runloop CFRunLoopRef CFRunLoopGetMain(void) { static CFRunLoopRef __main = NULL; // static 只会获取一次 if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); return __main; } // 获取当前thread对象的Runloop CFRunLoopRef CFRunLoopGetCurrent(void) { CHECK_FOR_FORK(); CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop); if (rl) return rl; return _CFRunLoopGet0(pthread_self()); //#include 中可以获取pthread_self } 获取 fps 通过 CADisplayLink 或 注册 observer 每次调用时间，得出 fps if (_lastTime == 0) { _lastTime = link.timestamp; return; } _count++; NSTimeInterval delta = link.timestamp - _lastTime; if (delta 卡顿监听 启动子线程，定时像主线程发送 ping，如果超时没有收到pong，则认为 此时主线程卡顿。获取当时的 stack trace 参考： http://mrpeak.cn/blog/ui-detect/ http://ios.jobbole.com/93085/ performSelector:afterDelay: 参考： https://blog.ibireme.com/2015/05/18/runloop/ https://mp.weixin.qq.com/s/XbdezDo2xu-9SaSmid2pbw MrPeak: https://mp.weixin.qq.com/s/XbdezDo2xu-9SaSmid2pbw "},"oc/keyword/associatedObject.html":{"url":"oc/keyword/associatedObject.html","title":"AssociatedObject","keywords":"","body":"AssociatedObject ask class AssociationsManager { // key 为 obj，value 为 ObjectAssociationMap 对象 AssociationsHashMap *map; static spinlock_t _lock; } // key 为 自定义的key @selector(method_name)， value 为 ObjcAssociation ObjectAssociationMap class ObjcAssociation { uintptr_t _policy; id _value; }; AssociationsHashMap { key: obj, value: ObjectAssociationMap { key : your_name, value: ObjcAssociation } } AssociationsManager AssociationsManager 为全局的单例 class AssociationsManager { static spinlock_t _lock; static AssociationsHashMap *_map; } AssociationsHashMap typedef hash_map AssociationsHashMap; key 为 obj的地址 value 为 一个ObjectAssociationMap ObjectAssociationMap typedef hash_map ObjectAssociationMap; key 为自定义的值 例如 @selector(helloMethod) value 为 ObjcAssociation ObjcAssociation class ObjcAssociation { uintptr_t _policy; id _value; }; 何时释放？ 当对象被释放时，会调用 _object_remove_assocations(obj) 移除关联对象 使用 objc_setAssociatedObject(self, @selector(selectedView), selectView, OBJC_ASSOCIATION_RETAIN_NONATOMIC); objc_getAssociatedObject(self, @selector(kd_selectedView)); // policy typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) { OBJC_ASSOCIATION_ASSIGN = 0, /**"},"oc/keyword/copy.html":{"url":"oc/keyword/copy.html","title":"copy","keywords":"","body":"系统对象分为了两类: 系统的非容器类对象，如 NSString、NSMutableString、NSNumber 等。 系统的容器类对象，如 NSArray、NSMutableArray、NSDictionary、NSMutableDictionary 等。 对于系统的非容器类对象 如果对一不可变对象(如 NSString)复制，copy 是指针复制(浅拷贝)和 mutableCopy 就是对象复制(深拷贝); 如果是对可变对象(如 NSMutableString)复制，copy 和 mutableCopy 都是深拷贝，但是 copy 返回的对象是不可变的。 对于系统的容器类对象 对不可变对象(如 NSArray)进行复制，copy 是指针复制(浅拷贝)， mutableCopy 是对象复制(深拷贝), 但是不管是 copy 还是 mutableCopy, 且不论容器内对象是可变还是不可变，返回的容器内对象都是指针复制(浅拷贝)。 对可变对象(如 NSMutableArray)进行复制时，copy 和 mutableCopy 都是对象复制(深拷贝)，但是不管是 copy 还是 mutableCopy，且不论容器内对象是可变还是不可变，返回的容器内对象都是指针复制(浅拷贝)。 参考 http://lincode.github.io/Copying "},"oc/keyword/block.html":{"url":"oc/keyword/block.html","title":"block","keywords":"","body":"block block的实质，就是一个struct，包含了一个指向函数首地址的指针，和一些与自己相关的成员变量。 struct __block_impl struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_a_0 *a; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a->__forwarding) { impl.isa = &_NSConcreteStackBlock; // 类型 impl.Flags = flags; impl.FuncPtr = fp; // / 要执行的函数指针 Desc = desc; } }; // 使用 static void __main_block_func_0(struct __main_block_impl_0 *__cself) { __Block_byref_a_0 *a = __cself->a; // bound by ref int b = (a->__forwarding->a); int m = 10; } Block类型 { // 全局的静态block，不会访问任何外部变量 NSConcreteGlobalBlock; // 保存在栈中的block，出栈时会被销毁 NSConcreteStackBlock; // 保存在堆中的block，当引用计数为0时会被销毁 NSConcreteMallocBlock;//分配在堆中 ｝ oc -> c++ clang -rewrite-objc main.m typedef void(^Block)(void); int main(int argc, char * argv[]) { // @autoreleasepool { // return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); // } __block int a = 10; Block block1 = ^() { // print(\"123\"); a = 11; // self.string = @\"456\"; }; } /////////////编译后的代码//////////// //变量a的处理：a会对应生成一个struct： struct __Block_byref_a_0 { void *__isa; __Block_byref_a_0 *__forwarding; int __flags; int __size; int a; }; // block 生成一个struct，里面有 对应的函数指针和 a的struct struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_a_0 *a; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a->__forwarding) { impl.isa = &_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; // 函数指针 static void __main_block_func_0(struct __main_block_impl_0 *__cself){ __Block_byref_a_0 *a = __cself->a; // bound by ref (a->__forwarding->a) = 11; } 参考 https://mp.weixin.qq.com/s/XqMIoqJ0a4BzWlozO5whDg "},"oc/keyword/StripedMap.html":{"url":"oc/keyword/StripedMap.html","title":"StripedMap","keywords":"","body":"锁分段技术 锁分段 就是进一步对一组独立的对象进行分解。 关于提高并发性 可以使用 锁分离(lock striping) 和 锁分拆(lock splitging) 两种方式。 如果一个锁守护多个独立的不同变量，可以通过分拆锁，使不同的锁守护不同变量，从而降低锁的请求频率。 例如Java中的ConcurrentHashMap的实现中使用了一个包含16个锁的数组，每个锁保护所有散列值的1/16，第N个散列桶有第(N mod 16)个锁来保护，所以这个并发集合可以支持最多16个并发的写入器。 例如在ObjC的runtime中使用的StripedMap中包含了64个锁的数组。 /** 下面是runtime库中的代码 */ template class StripedMap { enum { StripeCount = 64 }; static unsigned int indexForPointer(const void *p) { // c++ 从指针类型 转换成一个足够大的整数类型 uintptr_t addr = reinterpret_cast(p); // 右移后 取 异或运算，再取余 （最终得到一个小于StripeCount的随机数） return ((addr >> 4) ^ (addr >> 9)) % StripeCount; } T array[StripCount]; public: // 重写了[]运算 map[指针地址] 即可获取到一个对象 T& operator[] (const void *p) { return array[indexForPointer(p)].value; } }; 在runtime库中的用法 //里面放了64个spinklock对象，用于获取lock static StripedMap PropertyLocks; // 使用 spinlock_t& slotlock = PropertyLocks[slot]; slotlock.lock(); oldValue = *slot; *slot = newValue; slotlock.unlock(); spinlock_t的使用 class spinlock_t { os_lock_handoff_s mLock; public: spinlock_t() : mLock(OS_LOCK_HANDOFF_INIT) { } void lock() { os_lock_lock(&mLock); } void unlock() { os_lock_unlock(&mLock); } bool trylock() { return os_lock_trylock(&mLock); } // Address-ordered lock discipline for a pair of locks. // 两个指针指向的内容互换时，需要先锁定两个地址指向的内容 static void lockTwo(spinlock_t *lock1, spinlock_t *lock2) { if (lock1 > lock2) { // lock1 lock2 锁有先后顺序？ lock1->lock(); lock2->lock(); } else { lock2->lock(); if (lock2 != lock1) lock1->lock(); } } static void unlockTwo(spinlock_t *lock1, spinlock_t *lock2) { lock1->unlock(); if (lock2 != lock1) lock2->unlock(); } }; SideTables/RefcountMap/weak_table_t的使用\b struct SideTable { spinlock_t slock; // 锁保证 atomic /** RefcountMap disguises its pointers because we don't want the table to act as a root for `leaks`. 对象具体的引用计数存储在这里 */ RefcountMap refcnts; /** * The global weak references table. * Stores object ids as keys, and weak_entry_t structs as their values. */ weak_table_t weak_table; void lock() { slock.lock(); } void unlock() { slock.unlock(); } bool trylock() { return slock.trylock(); } // Address-ordered lock discipline for a pair of side tables. template static void lockTwo(SideTable *lock1, SideTable *lock2); template static void unlockTwo(SideTable *lock1, SideTable *lock2); }; struct weak_table_t { weak_entry_t *weak_entries; // 数组 存储了指向某个对象的所有弱引用的变量指针 size_t num_entries; uintptr_t mask; uintptr_t max_hash_displacement; }; /** */ struct weak_entry_t { DisguisedPtr referent; // 某个对象的指针 weak_referrer_t *referrers; // 数组 对这个对象的弱引用的变量地址存在这里 }; /// The address of a __weak object reference typedef objc_object ** weak_referrer_t; # 参考： os_lock_handoff_s参考：https://opensource.apple.com/source/libmalloc/libmalloc-116.30.3/src/locking.h.auto.html "},"oc/keyword/build.html":{"url":"oc/keyword/build.html","title":"build","keywords":"","body":"Xcode 编译流程 编译信息写入辅助文件，创建文件架构 .app 文件 处理文件打包信息 执行 CocoaPod 编译前脚本，checkPods Manifest.lock 编译.m文件，使用 CompileC 和 clang 命令 链接需要的 Framework 编译 xib 拷贝 xib ，资源文件 编译 ImageAssets 处理 info.plist 执行 CocoaPod 脚本 拷贝标准库 创建 .app 文件和签名 "},"oc/keyword/gcd.html":{"url":"oc/keyword/gcd.html","title":"GCD","keywords":"","body":"GCD 优先级 // 与用户交互的优先级 QOS_CLASS_USER_INTERACTIVE // 用户发起的服务，等待结果 QOS_CLASS_USER_INITIATED // 默认优先级 QOS_CLASS_DEFAULT // 用户不太关心任务的进度，但需要知道结果 QOS_CLASS_UTILITY // 后台加载 QOS_CLASS_BACKGROUND global queue 的优先级 #define DISPATCH_QUEUE_PRIORITY_HIGH 2 #define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 #define DISPATCH_QUEUE_PRIORITY_LOW (-2) #define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN 对应关系： * - DISPATCH_QUEUE_PRIORITY_HIGH: QOS_CLASS_USER_INITIATED * - DISPATCH_QUEUE_PRIORITY_DEFAULT: QOS_CLASS_DEFAULT * - DISPATCH_QUEUE_PRIORITY_LOW: QOS_CLASS_UTILITY * - DISPATCH_QUEUE_PRIORITY_BACKGROUND: QOS_CLASS_BACKGROUND - (void)qdGCDPriority { dispatch_queue_t queue = dispatch_queue_create(\"queue\", DISPATCH_QUEUE_CONCURRENT); dispatch_queue_global_t gQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_queue_t queue = dispatch_queue_create(\"queue\", DISPATCH_QUEUE_CONCURRENT); // 指定优先级创建队列 dispatch_queue_t queue1; dispatch_queue_attr_t attr1; attr1 = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, 0); queue1 = dispatch_queue_create(\"com.example.myqueue\", attr1); NSLog(@\"\"); } 参考：http://ios.jobbole.com/90207/ "},"oc/keyword/swift-oc.html":{"url":"oc/keyword/swift-oc.html","title":"Swift与ObjC比较","keywords":"","body":"Swift 与 ObjC 对比 Swift 更注重安全性、简单，oc更注重 灵活性 Swift 更注重值类型的数据结构，oc以c语言为基础，注重指针和索引 Swift 为静态语言，oc为动态语言，有runtime，可以在运行时动态增加class、修改方法 Swift 支持函数编程、面向协议编程、面向对象编程，oc支持面向对象编程 Swift 中把String、Array、Dictionary设计为值类型，在oc中为引用类型 值类型相比引用类型，最大优势在可以高效实用内存。值类型在栈上操作，引用类型在堆上操作 值类型是线程安全的，不必担心多线程对String、Array、Dictionary的操作 as 操作 extension 的使用 protocol 的使用 static 与 class Struct 和 Class 共同点： 都可以定义 store value 都可以定义 method 都可以定义 subscripts 都可以可以定义init 都可以定义extension 都可以conform protocol 不同点： Class可以继承，struct 不可以 Class 可以在runtime阶段 使用 as (type casting)来检查class type Class 可以使用 deinit 方法 释放资源 Class 通过 引用计数 来实现引用控制 Class 额外的capcity增加了Class的复杂度和开销，所以尽量使用struct 和 enum 更简单。 Value Type 指 A value type is a type whose value is copied when it’s assigned to a variable or constant, or when it’s passed to a function. === 与 == === 用来判断 两个obj reference 是否指向同一个obj == 使用的是 Equtable "},"oc/keyword/audio.html":{"url":"oc/keyword/audio.html","title":"音频","keywords":"","body":"音频处理 两套framework： #import 处理音频、视频多媒体内容，负责 capturing, processing, synthesizing, controlling 四个过程。 Audio分为 和 App内Audio处理 AVAudioSession负责interact with system audio AVAudioPlayer AVAudioRecorder #import 提供了 record、play audio，convert formats，parse audio streams，configure audio session Audio Queue Service 一个queue负责连接audio硬件，管理内存，管理音频格式，管理 录音和播放。 queue创建和销毁： AudioQueueNewOutput AudioQueueNewInput AudioQueueDispose // 销毁 queue管理： AudioQueueStart AudioQueuePrime // 做准备 AudioQueueFlush AudioQueueStop // stop 会reset queue，并且会停止queue，断开连接的硬件设备。重新调用start也没用。 AudioQueuePause // pause不会影响buffers，也不会reset queue，调用AudioQueueStart则会重新resume AudioQueueReset 管理queue的属性 AudioQueueSetProperty AudioQueueGetProperty AudioQueueRef "},"oc/keyword/NSDictionary.html":{"url":"oc/keyword/NSDictionary.html","title":"NSDictionary","keywords":"","body":"NSMutableDictionary 与 NSDictionary 使用 Key 与 Value 类型 a key-value paire is called an entry 在 Dictionary 中，key 是唯一的(使用 isEqual: 来比较)。 key 可以是任意对象(保证实现了 NSCopying 协议即可) key 与 value 都不可以为 nil，但可以使用 [NSNull null] 定义类，实现NSCopying协议，该对象实例就可以作为key @interface MyKey: NSObject @end @implementation MyKey - (id)copyWithZone:(NSZone *)zone { MyKey *copy = [[MyKey alloc] init]; return copy; } @end 具体使用： NSMutableDictionary *dict1 = @{}.mutableCopy; // MyKey 作为 key，每次都会copy一个新实例作为 字典的key MyKey *key = [[MyKey alloc] init]; // @(2) 为 NSNumber 的简写 [dict1 setObject:@(2) forKey:key]; // value 可以为 [NSNull null] [dict1 setObject:[NSNull null] forKey:key]; [dict1 setObject:[NSNull null] forKey:key]; // key 可以使用 [NSNull null] 唯一，所以会覆盖 [dict1 setObject:@(3) forKey:[NSNull null]]; [dict1 setObject:@(4) forKey:[NSNull null]]; 注意 - (void)setValue:(nullable id)value forKey:(NSString *)key; 中的key为 NSString [dict1 setValue:[NSNumber numberWithInt:1] forKey: key]; 打印结果： (lldb) po dict1 { \"\" = 1; \"\" = \"\"; \"\" = \"\"; \"\" = 4; \"\" = 2; } 桥接 通过 __bridge 桥接 Core Foundation 与 Cocoa 中对应的类 NSString *str = (__bridge NSString *)strRef; NSString *hello = @\"hello\"; CFStringRef helloRef = (__bridge CFStringRef)hello; CFDictionaryRef NSDictionary is “toll-free bridged” with its Core Foundation counterpart, CFDictionaryRef. typedef struct __CFDictionary *CFDictionaryRef; CFStringRef keys[3]; keys[0] = CFSTR(\"key1\"); keys[1] = CFSTR(\"key2\"); keys[2] = CFSTR(\"key3\"); CFStringRef values[3]; values[0] = CFSTR(\"values1\"); values[1] = CFSTR(\"values2\"); values[2] = CFSTR(\"values3\"); /// immutable CFDictionaryRef dictRef = CFDictionaryCreate(kCFAllocatorDefault, (void *)keys, (void *)values, 3, NULL, NULL); CFIndex count = CFDictionaryGetCount(dictRef); // copy CFDictionaryRef dict1Ref = CFDictionaryCreateCopy(kCFAllocatorDefault, dictRef); // ... CFRelease(dictRef); CFRelease(dict1Ref); CFMutableDictionaryRef /// mutable 个数为0 表示不限制个数 CFMutableDictionaryRef mDictRef = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, NULL, NULL); // add CFDictionaryAddValue(mDictRef, CFSTR(\"key0\"), CFSTR(\"value0\")); const void * value = CFDictionaryGetValue(mDictRef, CFSTR(\"key0\")); // 使用完释放 CFRelease(mDictRef); CFStringRef 与 CFMutableStringRef CFStringRef strRef = CFSTR(\"你好\"); // 0 为 没有大小限制 CFMutableStringRef mStrRef = CFStringCreateMutable(kCFAllocatorDefault, 0); CFStringAppend(mStrRef, strRef); CFStringAppend(mStrRef, CFSTR(\"，Peter\")); CFRelease(strRef); CFRelease(mStrRef); CFArrayRef 参考 官方文档：https://developer.apple.com/documentation/foundation/nsdictionary?language=objc "},"swift/":{"url":"swift/","title":"Swift","keywords":"","body":"Swift 官方文档：https://docs.swift.org/swift-book/ 知识点： Basic Basic Operation/Control Flow Basic Type/String/Character/Collection Type Function/Closures Enumeration/Structure/Class/Protocol Property Method Initialization/Deinitialization Extension Other Subscript Optional Chain Error Handling Type Casting Nested Types Generic ARC/Memory Safety Range Operator 范围 a range of values // Closed Range 左闭右闭 [1,5] for index in 1...5 { // } // Half-Open Range Operator 左闭右开 [1,5) for index in 1..Type Casting 类型检测 is type check operator 可以用来检测 是否是子类 或 实现了 protocol for item in library { if item is Movie { print(\"Movie \\(item.name)\") } else if item is Song { print(\"Song \\(item.name)\") } } 类型转换 as? 与 as! 可以转成父类 或 实现的 protocol // as? as! for item in library { if let movie = item as? Movie { print(\"Movie: \\(movie.name), dir. \\(movie.director)\") } else if let song = item as? Song { print(\"Song: \\(song.name), by \\(song.artist)\") } } // 转成 Any 或者 AnyObject 直接使用 as 即可。 // as for item in library { _ = item as? Movie _ = item as AnyObject } Any 与 AnyObject Any 代表一个instance，包括 Function AnyObject 代表一个Class 的 instance "},"swift/closure.html":{"url":"swift/closure.html","title":"Closure","keywords":"","body":"Closure 和 Function Function 是特殊的 Closure，Function 分为 Global Function 和 Nested Function。 Closure 有3种情况： Global Function。有 name ，并且没有 capture 任何值 Nested Function。有 name，并且在定义范围内(enclosing funtion)可以 capture 值。 Closure Expression。没有 name，能够 capture 上下文中的值 Closure Expression Syntax /// 声明 Cloruse 类型： (param) -> return_value /// 实现： { (param) -> return_value in statements ... } param 可以为 in-out 参数，但不可以设置默认值。() 表示参数为空 示例： // 声明 var checkClosure: ((Bool) -> Void)? // 实现 checkClosure = { [weak self] () -> Void in self?.isLunar = false } 语法的优化 根据上下文推断参数和返回值的类型 let names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"] func sort(_ a: String, _ b: String) -> Bool { return true } let sort1: (String, String) -> Bool = { (a: String, b: String) -> Bool in return true } let sort2: (String, String) -> Bool = { (a: String, b: String) in return true } let sort3 = { (a: String, b: String) in return true } _ = names.sorted(by: sort2) reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } ) reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } ) reversedNames = names.sorted(by: { $0 > $1 } ) reversedNames = names.sorted(by: >) Trailing Closures func someFunctionThatTakesAClosure(closure: () -> Void) { // function body goes here } // 调用： someFunctionThatTakesAClosure() { // trailing closure's body goes here } Closure 是 引用类型 引用类型，不是值类型。 Escaping Closure 如果一个闭包被作为一个参数传递给一个函数，并且在函数return之后才被唤起执行（return后 不会被销毁），那么这个闭包是逃逸闭包。 使用场景： 异步执行。函数 return 后，异步执行 闭包。 闭包存储在全局变量中，等待以后使用。 var completionHandlers: [() -> Void] = [] func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) { completionHandlers.append(completionHandler) } "},"swift/property.html":{"url":"swift/property.html","title":"Property","keywords":"","body":"Property Stored Property Stored Property 可以为 var 或 let ，会存储 value 作为对象的一部分 Stored Property 可以设置默认值 可以在 init 方法中修改 Stored Property 的值(let 如果未初始化，则可以在init中赋值) var firstName: String = \"\" var lastName: String? Class 和 Struct 的使用区别： class Person { var firstName: String = \"\" var lastName: String // class 的 Stored Property 在 init 的时候必须初始化 init(_ lastName_: String) { lastName = lastName_ } } struct FixedRange { var firstValue: Int let length: Int } // class 为 reference type，如果为let，仍然可以修改 var property let person = Person(\"LBJ\") person.firstName = \"Peter\" person.lastName = \"LBJ\" // struct 为 value type，如果为let，则所有的 property 都为let，不可修改 let range = FixedRange(firstValue: 5, length: 10) range.firstValue = 6 // 编译错误 Lazy Stored Property Lazy Stored Property 的初始化会延迟到 第一次被调用 class DataManager { lazy var importer = DataImporter() var data = [String]() lazy var fullName = { // 注意：正常只会调用一次；但如果多线程操作，无法保证只初始化一次 return firstName + lastName }()**** } Computed Property Computed Property 不会存储值，会默认生成 getter 方法，默认没有 setter 方法，可以自定义设置 setter 方法。 class/struct/enum 可以定义 Computed Property。 var firstName: String = \"\" var lastName: String = \"\" // default getter，没有 setter， readonly var fullName: String { return firstName + lastName } // 显示的 getter，没有 setter， readonly var fullName: String { get { return firstName + lastName } } // setter and **getter** var fullName: String { get { return firstName + lastName } set(newName) { firstName = newName } } // setter 的简写 var fullName: String { get { return firstName + lastName } set { firstName = newValue } } // Computed Property 调用： _ = person.fullName person.fullName = \"\" //// 实际作用等价于下面的函数 func fullName() -> String { return firstName + lastName } func fullName(_ newName: String) { firstName = newName } // 函数调用 _ = person.fullName() person.fullName(\"\") Property Observer Observer 分为 willSet 和 didSet 两种 可以为 Stored Property 添加 Observer（不可以给 Lazy Stored Property 添加 Observer） class：继承的 Stored Property 和 Computed Property 都可以添加 Observer（overriding Property） 对于自己定义的 Computed Property 并不需要添加 Observer，可以直接在 setter 中处理() 在 init 中初始化的时候，不会调用 Observer class Animal { var firstName: String { get { return \"\" } set { print(\"set\") } } var age: Int = 0 } class Person: Animal { var lastName: String = \"\" { willSet { print(\"old: \" + lastName + \", new: \" + newValue) } didSet { print(\"old: \" + oldValue + \", new: \" + lastName) } } // 这里会报错 lazy 无法添加 observer // lazy var firstName: String = \"\" { // willSet { // print(\"old: \" + lastName + \", new: \" + newValue) // } // } // override Stored Property override var age: Int { willSet { print(\"willSet age\") } didSet { print(\"didSet age\") } } // override Computed Property override var firstName: String { willSet { print(\"willSet\") } didSet { print(\"didSet\") } } } Type Property 类似于 c 中的 static，必须有默认值(default value) class Person { static var lastName: String = \"\" { willSet { print(\"old: \" + lastName + \", new: \" + newValue) } didSet { print(\"old: \" + oldValue + \", new: \" + lastName) } } static var firstName1: String { get { return \"\" } set { print(\"\") } } // 使用 class 修饰 Computed Property ， subclass 可以 override class var firstName: String { get { return \"\" } set { print(\"\") } } } struct FixedRange { static var firstValue: Int = 0 let length: Int } enum KDError { case networkError static var firstValue: Int = 0 } // 调用方式： Person.lastName = \"\" FixedRange.firstValue = 10 参考 https://docs.swift.org/swift-book/LanguageGuide/Properties.html#ID255 "},"swift/generic.html":{"url":"swift/generic.html","title":"泛型","keywords":"","body":"泛型 "},"swift/where.html":{"url":"swift/where.html","title":"where","keywords":"","body":"Swift 中 where 的使用 where 在 switch、for in 语句上 增加限制条件 var arr = [Int]() arr.append(1) arr.append(2) arr.append(3) for elemnet in arr where elemnet == 2 { print(elemnet) } arr.forEach { (value) in switch value { case let x where x > 2: print(\"\\(x) 大于2\") default: print(\"default\") } } 在 do catch 里面使用 enum ExceptionError: Error { case httpCode(Int) } func throwError() throws { throw ExceptionError.httpCode(404) } func test1() { do { try throwError() } catch ExceptionError.httpCode(let code) where code > 500 { print(404) } catch { print(\"other err\") } } 只给遵守 MyProtocol 协议的 MyClass类或子类增加扩展 // 与协议结合 protocol MyProtocol { // } class MyClass { // } // 只给遵守 MyProtocol 协议的 MyClass类或子类增加扩展 extension MyProtocol where Self: MyClass { func getName() -> String { return \"MyClass\" } } class SubClass: MyClass, MyProtocol { // } 在 associatedtype 后面声明的类型后追加 where 约束语句 protocol MyProtocol { associatedtype Element where Element: MyClass } class MyClass { // } "},"swift/codable.html":{"url":"swift/codable.html","title":"codable","keywords":"","body":"codable 涉及到的类：Codable、JSONEncoder、Mirror、JSONSerialization Codable 类转 Dict // public typealias Codable = Decodable & Encodable struct Cat: Codable { var name: String var age: Int } let peter = Cat(name: \"Peter\", age: 12) let encoder = JSONEncoder() do { let data = try encoder.encode(peter) let dict = try JSONSerialization.jsonObject(with: data, options: []) print(dict) } catch { print(error) } Codable 转 String public extension Encodable { public func kd_jsonString() throws ->String? { let data = try JSONEncoder().encode(self) let str = String.init(data: data, encoding: String.Encoding.utf8) return str } } KeyedEncodingContainer 与 KeyedDecodingContainer JSONEncoder encode 对象的时候，基本基于 KeyedEncodingContainer JSONDecoder decode json对象的时候，基本基于 KeyedDecodingContainer 可以通过 KeyedEncodingContainer 或 KeyedDecodingContainer 增加扩展，重写对应的encode decode 方法，提升 json 转 对象的兼容性 extension KeyedDecodingContainer { func decodeIfPresent(_ type: String.Type, forKey key: K) throws -> String? { var defaultValue: String? if let key = key as? YZJCodingKey { let value = key.defaultValue(key: key.stringValue) defaultValue = value as? String } do { let value = try decode(type, forKey: key) return value }catch { let err = error as! DecodingError switch err { case .typeMismatch(_, _): if let value = try? decode(Int.self, forKey: key) { return String(value) ?? defaultValue } if let value = try? decode(Float.self, forKey: key) { return String(value) ?? defaultValue } if let value = try? decode(Bool.self, forKey: key) { return String(value) ?? defaultValue } if let anyObject = try? decode(YZJAnyDecodable.self, forKey: key) { if let data = try? JSONSerialization.data(withJSONObject: anyObject.value, options: JSONSerialization.WritingOptions.prettyPrinted), let str = String.init(data: data, encoding: String.Encoding.utf8) { return str } } default: break } } return defaultValue } } 参考 https://xiaozhuanlan.com/topic/9582316047 "},"swift/arc.html":{"url":"swift/arc.html","title":"ARC中的循环引用","keywords":"","body":"ARC 相关 类实例之间的循环引用 1.两个类中的 property 都可能为 nil class Person { let name: String init(name: String) { self.name = name } var apartment: Apartment? deinit { print(\"\\(name) is being deinitialized\") } } class Apartment { let unit: String init(unit: String) { self.unit = unit } weak var tenant: Person? deinit { print(\"Apartment \\(unit) is being deinitialized\") } } 2.两个类中的 property ，一个可能为 nil，另一个不可能为 nil class Customer { let name: String var card: CreditCard? init(name: String) { self.name = name } } class CreditCard { let number: UInt64 unowned var customer: Customer init(number: UInt64, customer: Customer) { self.number = number self.customer = customer } } 3.两个类中的 property 都不可能为 nil class Country { let name: String var capitalCity: City! init(name: String, capitalName: String) { self.name = name self.capitalCity = City(name: capitalName, country: self) } } class City { let name: String unowned let country: Country init(name: String, country: Country) { self.name = name self.country = country } } Closure 的循环引用 使用 Capture List 来避免循环应用。 注意 只有调用了 Closure 才会触发循环引用 1.可能为 nil 使用 [weak self] lazy var asHTML: () -> String = { [weak self] in if let text = self?.text { return \"\\(text)\" } else { return \"\" } } 2.不可能为 nil 使用 [unowned self] lazy var asHTML: () -> String = { [unowned self] in if let text = self.text { return \"\\(text)\" } else { return \"\" } } "},"ios/basic/":{"url":"ios/basic/","title":"iOS系统","keywords":"","body":"程序运行 compile time compiler link time linker load time 程序被加载器(loader)加载到内存并执行 run time 由应用程序来执行 LLVM LLVM是一个模块化和可重用的编译器和工具链技术的集合，Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器。 更多介绍：http://www.aosabook.org/en/llvm.html clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。 lld 是 Clang / LLVM 的内置链接器，clang 必须调用链接器来产生可执行文件。 ASLR ASLR(address space layout randomization)，地址空间随机布局 aslr是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术 参考： https://ming1016.github.io/2017/03/01/deeply-analyse-llvm/ ASLR：http://wiki.jikexueyuan.com/project/ios-security-defense/aslr.html "},"ios/basic/compile.html":{"url":"ios/basic/compile.html","title":"编译","keywords":"","body":"编译 https://objccn.io/issue-6-2/ https://objccn.io/issue-6-3/ https://github.com/macmade/ClangKit https://github.com/aidansteele/osx-abi-macho-file-format-reference 编译 编译器会把每个 .m/.c/.mm 文件 编译成 .o 文件 (编译过程中会有 .d/.dia 中间文件生成) MyClass.m -> MyClass.d + MyClass.dia MyClass.o 编译完成后，linker 会链接 .o 文件，合并后生成可执行文件 举例编译 链接 参考： https://www.jianshu.com/p/9fc7776cce9b Xcode 工程编译流程 编译信息写入辅助文件，创建文件架构 .app 文件 处理文件打包信息 执行 CocoaPod 编译前脚本，checkPods Manifest.lock 编译.m文件，使用 CompileC 和 clang 命令 链接需要的 Framework 编译 xib 拷贝 xib ，资源文件 编译 ImageAssets 处理 info.plist 执行 CocoaPod 脚本 拷贝标准库 创建 .app 文件和签名 参考： https://juejin.im/post/5a352bb0f265da433562d5e3 加快编译速度 参考： https://juejin.im/post/59539377f265da6c415f064d https://medium.com/swift-programming/swift-build-time-optimizations-part-2-37b0a7514cbe dsym文件 程序在执行时通过地址来调用函数。dsym文件中储存了函数地址映射，函数地址可以通过dsym文件映射到具体函数位置。 代码文件 可执行文件 Object 静态库文件 动态库文件 标识 从 Mach64 Header 中可以读出 File Type 可执行文件中数据 一个代码二进制文件中 包含的不同区域 成为 Segment 在运行时，虚拟内存会把segment映射到进程的地址空间，按需加载(mmap技术) Segment 具体分为： __TEXT segment 包含被执行的代码，被只读和可执行的方式映射。 __cstring 可执行文件中的字符串 __const 不可变的常量 __text 包含编译后的机器码 stubs 和 stub_helper 是给动态链接器 dyld 使用，可以允许延迟链接 __DATA segment 以可读写和不可执行的方式映射（里面的数据可以被改变） __LINKEDIT __PAGEZERO Mach-O文件 头部信息: struct mach_header { uint32_t magic; cpu_type_t cputype; cpu_subtype_t cpusubtype; uint32_t filetype; uint32_t ncmds; uint32_t sizeofcmds; uint32_t flags; }; 参考： http://blog.cnbang.net/tech/2296/ http://www.cloudchou.com/android/post-992.html https://stackoverflow.com/questions/32003262/find-size-contributed-by-each-external-library-on-ios "},"ios/basic/linker.html":{"url":"ios/basic/linker.html","title":"链接","keywords":"","body":"链接 链接（linking) 是将 代码片段(TEXT) 和 数据片段(DATA) 收集并组合成一个单一文件的过程，这个文件可被加载到内存中并执行。 Linker 链接器 目标文件纯粹是字节块的集合。这些块中包含程序代码、程序数据，也包含引导Linker和Loader数据结构。 Linker将这些字节块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。 Linker有两个作用： 符号解析(symbol resolution)。符号解析的目的是 将每个符号引用 和 一个符号定义正好联系起来。 重定位(relocation)。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义和一个内存位置关联起来，从而成功定位这些节，然后修改所有对这些符号的引用，使得他们指向这个内存位置。 与静态库链接 Link Binary To Libraries .a are static library ，会被编译成程序的一部分； .dylib are dynamic library ，不会编译到程序中，link的时候会dynamically linked .framework 在link的时候会dynamically linked http://stackoverflow.com/questions/6245761/difference-between-framework-and-static-library-in-xcode4-and-how-to-call-them https://discussions.apple.com/thread/1895619?start=0&tstart=0 制作.a 文件： http://blog.csdn.net/pjk1129/article/details/7255163 framework学习很好的文章： http://gaobusi.iteye.com/blog/1684415 Mach-O 可执行文件 动态库 和 静态库的各自特点 通过写代码体验 静态库 和 动态库的区别 iOS中使用 动态库 和 静态库 动态库和静态库的格式 .a 格式为 \"ar archive\"，为静态库。Xcode创建项目时可选。使用.a文件，注意需要手动导入 头文件和bundle。 关于Framework的使用 动态库 和 静态库 都可以是Framework 系统的.framework是动态库，CocoaPods现在项目中默认是动态库。用Xcode创建Framework的时候默认是动态库，可以修改Build Settings的Mach-O Type为Static Library，使Framework为静态库。 什么是Framework Framework是一个Cocoa程序中一种资源打包方式，可以把代码、头文件、资源文件打包为一个Framework文件，方便开发使用。 静态Framework无法读取资源文件？ framework中资源读取问题: 动态库就是一个Bundle，指定为当前Bundle就可以读取图片等相关资源 '' // bundle参数如果不传，默认是mainBundle。 '' NSBundle *bundle = [NSBundle bundleForClass:self.class]; '' UIImage *img = [UIImage imageNamed:@\"live_placeHolder_headerImg\" inBundle:bundle compatibleWithTraitCollection:nil]; '' 注意:在主程序中读framework里面的资源文件也如上 静态库，代码会编译进可执行文件中。需要生成一个对应Bundle，copy到项目中。(CocoaPods就是这样做) 动态库、静态库比较： https://www.jianshu.com/p/743deabe15ae?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation https://github.com/awesome-tips/iOS-Tips/blob/master/2018/07.md#objective-c-import-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%A4%B4%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93 代码和资源的打包在一起 dynamic framework 私有的动态库，只能放在自己的沙盒内。主app和插件extension可共用 static framework dylib 介绍：https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html 相关概念 相关工具 "},"ios/basic/startapp.html":{"url":"ios/basic/startapp.html","title":"App运行","keywords":"","body":"iOS App运行 启动流程 加载 App 可执行文件 加载 dyld 和 动态链接库 dyld 是专门用来加载动态链接库的库。dyld 从App 可执行文件的依赖开始，递归加载所有依赖的动态链接库 ImageLoader App 可执行文件 和 动态库 都是 image 文件。每一个 image 文件对应一个 ImageLoader 实例来负责加载。 动态库加载流程 load dylib image rebase image bind image objc setup initializers load dylib image 读取动态链接库，加载到内存 分析依赖的动态库 打开文件，验证签名 动态库的每个 segment 调用 mmap() 映射到内存 rebase/bind 使用 ASLR 技术，每次 dylib 会加载到新的随机地址(actual_address)，代码和数据中原来指向的旧地址(preferred_address)。dyld 需要纠正新旧地址的偏差(slide)，这个过程就叫 rebase，做法就是把 dylib 中代码和数据的指针地址都加上这个偏移量。 slide = actual_address - preferred_address rebase 操作：把 image 读入内存，并对 dylib 中的指针地址纠正偏移量。 rebase 主要瓶颈在 I/O 操作。 binding 操作 是处理dylib中指向外部的指针。从 可执行文件中的 LINKEDIT 中读取需要 bind 的指针 和 指针指向的符号，然后从符号表中查找对应实现，将实现存储到 DATA 中的那个指针。 binding 操作需要大量 CPU 计算。 objc setup 1. 注册 objc 类 class registration objc runtime 维护着一张 映射 类名和类的全局表。当加载一个 dylib 时，其定义的所有类都需要被注册到全局表中 2. 把category的定义插入方法列表 category registration class 加载完后，会加载 category 。把 category 中定义的方法都加在到 方法列表中。 3. 保证每一个 selector 唯一 initializers 1. objc 的 +load 函数 可执行文件 和 动态库 加载完，并且 执行完 objc setup 后，可执行文件中和动态库所有的符号(Class，Protocol，Selector，IMP，…)都已经按格式成功加载到内存中，被 runtime 所管理。在这之后，runtime 的那些方法(动态添加 Class、swizzle 等等才能生效) Linux 加载可执行目标文件 运行时内存映像： 内存内核 ======= 2^48-1 地址 用户栈(运行时创建) ... ... void _objc_init(void) { static bool initialized = false; if (initialized) return; initialized = true; // 各种初始化 environ_init(); tls_init(); static_init(); lock_init(); // 看了一下exception_init是空实现！！就是说objc的异常是完全采用c++那一套的。 exception_init(); // 注册dyld事件的监听 _dyld_objc_notify_register(&map_2_images, load_images, unmap_image); } 初始化流程： class从二进制里面读出来 加载到一个全局的map中 分别读取每个class，初始化 初始化流程： fix selector 唯一性 读取 protocol 读取class attach category 子类的 load 方法会在父类方法执行完成之后执行，分类的 +load 会在主类执行之后执行。 Category 中的方法列表加到 Class 的 methed_list_t 里面去。而且是插入到 Class 方法列表的前面（这就是 Category 中重写主类的方法导致的方法覆盖的原因） load 与 initialize load 是在被添加到 runtime 时开始执行，父类最先执行，然后是子类，最后是 Category。又因为是直接获取函数指针来执行，不会像 objc_msgSend 一样会有方法查找的过程。 initialize 不会被调用。类接收消息时，运行时会先检查 + initialize 有没有被调用过。如果没有，会在消息被处理前调用 initialize 最终是通过 objc_msgSend 来执行的，objc_msgSend 会执行一系列方法查找，并且 Category 的方法会覆盖类中的方法。 参考 https://juejin.im/entry/5837a4fac59e0d006b2ab8d5 http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/ 参考 https://techblog.toutiao.com/2018/05/29/untitled-24/ http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/ http://blog.sunnyxx.com/2014/08/30/objc-pre-main/ "},"ios/basic/startruntime.html":{"url":"ios/basic/startruntime.html","title":"start-runtime","keywords":"","body":"runtime 启动 调用时机： 参考：https://bestswifter.com/runtime-category/ void _objc_init(void) └──const char *map_2_images(...) └──const char *map_images_nolock(...) └──void _read_images(header_info **hList, uint32_t hCount) void _objc_init(void) { static bool initialized = false; if (initialized) return; initialized = true; // 读取Xcode 中的环境配置参数 environ_init(); tls_init(); static_init(); lock_init(); exception_init(); // === runtime 加载 // Register for unmap first, in case some +load unmaps something // unmap_image _dyld_register_func_for_remove_image(&unmap_image); // map_2_images 中有部分初始化 和 read_images 操作 dyld_register_image_state_change_handler(dyld_image_state_bound, 1/*batch*/, &map_2_images); // load_images dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &load_images); } 调用 Mach-O 中 __objc_init_func 中定义的 函数 // Run C++ static constructor functions static void static_init() { #if __OBJC2__ size_t count; Initializer *inits = getLibobjcInitializers(&_mh_dylib_header, &count); for (size_t i = 0; i map_2_images 中的操作 const char * map_images_nolock(enum dyld_image_states state, uint32_t infoCount, const struct dyld_image_info infoList[]) { static bool firstTime = YES; static bool wantsGC = NO; uint32_t i; header_info *hi; header_info *hList[infoCount]; uint32_t hCount; size_t selrefCount = 0; // Perform first-time initialization if necessary. // This function is called before ordinary library initializers. // fixme defer initialization until an objc-using image is found? if (firstTime) { preopt_init(); } // Find all images with Objective-C metadata. hCount = 0; i = infoCount; while (i--) { const headerType *mhdr = (headerType *)infoList[i].imageLoadAddress; hi = addHeader(mhdr); if (!hi) { // no objc data in this entry continue; } if (mhdr->filetype == MH_EXECUTE) { // 可执行文件中加载 objc 的 meta info // Size some data structures based on main executable's size size_t count; // 读取 __objc_selrefs _getObjc2SelectorRefs(hi, &count); selrefCount += count; // 读取 __objc_msgrefs _getObjc2MessageRefs(hi, &count); selrefCount += count; } hList[hCount++] = hi; } if (firstTime) { // 首次 初始化 selector table 并且把上面读取的 SEL 注册到 table 中 // Initialize selector tables and register selectors used internally sel_init(wantsGC, selrefCount); // 初始化 AutoreleasePoolPage 和 存储引用计数的 StripedMap arr_init(); } // 类、方法、协议、category 加载 _read_images(hList, hCount); firstTime = NO; return NULL; } sel_init(wantsGC, selrefCount); 中注册了部分 SEL #define s(x) SEL_##x = sel_registerNameNoLock(#x, NO) #define t(x,y) SEL_##y = sel_registerNameNoLock(#x, NO) sel_lock(); s(load); s(initialize); t(resolveInstanceMethod:, resolveInstanceMethod); t(resolveClassMethod:, resolveClassMethod); t(.cxx_construct, cxx_construct); t(.cxx_destruct, cxx_destruct); s(retain); s(release); s(autorelease); s(retainCount); s(alloc); t(allocWithZone:, allocWithZone); s(dealloc); s(copy); s(new); s(finalize); t(forwardInvocation:, forwardInvocation); t(_tryRetain, tryRetain); t(_isDeallocating, isDeallocating); s(retainWeakReference); s(allowsWeakReference); sel_unlock(); #undef s #undef t arr_init 初始化 void arr_init(void) { AutoreleasePoolPage::init(); SideTableInit(); // new (SideTableBuf) StripedMap(); } _read_images 中执行的操作 从 __objc_classlist 加载 class classref_t *classlist = _getObjc2ClassList(hi, &count); for (i = 0; i 从 __objc_classrefs 读取 class Class *classrefs = _getObjc2ClassRefs(hi, &count); for (i = 0; i 注册 SEL SEL *sels = _getObjc2SelectorRefs(hi, &count); UnfixedSelectors += count; for (i = 0; i 从 __objc_protolist 读取 protocol protocol_t **protolist = _getObjc2ProtocolList(hi, &count); for (i = 0; i 从 __objc_catlist 加载 category 加载完 category 后，重新 设置 class method list category_t **catlist = _getObjc2CategoryList(hi, &count); for (i = 0; i cls); if (!cls) { // Category's target class is missing (probably weak-linked). // Disavow any knowledge of this category. catlist[i] = nil; if (PrintConnecting) { _objc_inform(\"CLASS: IGNORING category \\?\\?\\?(%s) %p with \" \"missing weak-linked target class\", cat->name, cat); } continue; } // 加载完 category 后，会重新调整 class method list // Process this category. // First, register the category with its target class. // Then, rebuild the class's method lists (etc) if // the class is realized. bool classExists = NO; if (cat->instanceMethods || cat->protocols || cat->instanceProperties) { addUnattachedCategoryForClass(cat, cls, hi); if (cls->isRealized()) { remethodizeClass(cls); classExists = YES; } if (PrintConnecting) { _objc_inform(\"CLASS: found category -%s(%s) %s\", cls->nameForLogging(), cat->name, classExists ? \"on existing class\" : \"\"); } } if (cat->classMethods || cat->protocols /* || cat->classProperties */) { addUnattachedCategoryForClass(cat, cls->ISA(), hi); if (cls->ISA()->isRealized()) { remethodizeClass(cls->ISA()); } if (PrintConnecting) { _objc_inform(\"CLASS: found category +%s(%s)\", cls->nameForLogging(), cat->name); } } } load_images 调用 load 方法 const char * load_images(enum dyld_image_states state, uint32_t infoCount, const struct dyld_image_info infoList[]) { bool found; // 判断是否有 load 方法 // Return without taking locks if there are no +load methods here. found = false; for (uint32_t i = 0; i 0) return true; // 在 Mach-O 中对应 __objc_nlcatlist if (_getObjc2NonlazyCategoryList(mhdr, &count) && count > 0) return true; return false; } void call_load_methods(void) { static bool loading = NO; bool more_categories; loadMethodLock.assertLocked(); // Re-entrant calls do nothing; the outermost call will finish the job. if (loading) return; loading = YES; void *pool = objc_autoreleasePoolPush(); do { // 首先会把所有的 class 的 load 调用完 // 1. Repeatedly call class +loads until there aren't any more while (loadable_classes_used > 0) { call_class_loads(); } // 开始 调用 category 的 load // 2. Call category +loads ONCE more_categories = call_category_loads(); // 3. Run more +loads if there are classes OR more untried categories } while (loadable_classes_used > 0 || more_categories); objc_autoreleasePoolPop(pool); loading = NO; } runtime 加载 https://www.jianshu.com/p/c54efcb54018 "},"ios/basic/objectfile.html":{"url":"ios/basic/objectfile.html","title":"目标文件","keywords":"","body":"目标文件 目标文件是字节块的集合 目标文件有3种形式： 可重定位目标文件。包含二进制代码和数据，可以在链接是与其他可重定位目标文件合并起来，创建一个可执行目标文件。 可执行目标文件。包含二进制代码和数据，可以被加载器(loader)加载到内存并执行 共享目标文件。一种特殊的可重定位目标文件，可以在程序紧挨着是被动态的加载进内存并链接。 不同操作系统的目标文件 第一个 Unix系统 使用 a.out 格式 现代的x86-64 Linux 和 Unix 使用 可执行可链接格式(ELF, Executable and Linkable Format) Mac OS使用 Mach-O 格式 Windows 使用 PE 格式 不同系统的目标文件格式，基本概念都是相似的。 ELF 目标文件格式 [ ELF头部 ] [ .text ] // 代码 [ .rodata ] // 只读数据（常量） [ .data ] // 已初始化的全局和静态c变量(局部变量被保存在栈中) [ .bss ] // 未初始化的全局和静态c变量，以及被初始化为0的全局和静态变量 [ .symtab ] // 符号表 [ .rel.text ] // text的重定位信息 [ .rel.data ] // data的重定位信息 [ .debug ] // 调试符号表(默认编译不会有这个section) ... [ 节头部表 ] ELF头部。占16字节，描述了生成该文件的字的大小和字节顺序，目标文件累心，机器类型，节头部表的文件偏移。 节头部表(section header table) 描述了不同节的位置和大小。 在ELF头部 和 节头部之间的都是节Section .bss 这个section实际没有占实际的空间，仅仅是占位符。程序运行时，再分配内存，初始值为0 .symtab 符号表(symbol table)，存放着程序中定义和引用的函数和全局变量的信息。 .rel.text 和 .rel.data 当linker 把目标文件和其他文件组合时，需要修改这些位置。一般，对任何调用外部函数或引用全局变量的指令都需要修改。 可执行目标文件中不需要成功定位信息，因此可以省略。 符号和符号表 符号 每个可重定位目标块m都有一个符号表，它包含了m定义和引用的符号信息。 在链接器的上下文中，有3种不同的符号： 由m定义的全局符号(可以被其他模块引用)。对应于非静态的c函数和全局变量 由其他模块定义，并被模块m引用的全局符号。，这些符号被称为外部符号，对应于其他模块定义的非静态c函数和全局变量 由m定义和引用的局部符号。对应于带static的c函数和全局变量。局部符号在模块m内可见，外部无法引用 在 c语言中，源文件扮演模块的角色，一个源文件就是一个模块，编译生成一个.o文件。 任何带有static修饰的全局变量或函数都是模块私有的。 符号表 .symtab section中包含ELF符号表，是一个 Elf64_Symbol 数组 一个 Elf64_Symbol 对应一个 符号 typedef struct { int name; // 字符串表中的字节偏移 符号字符串名称以 null 结尾 char type:4 // Function of data ,binding:4; // local or global 本地还是全局符号 char reserved; // 未使用 short section; // section index long value; // section offset or absolute address long size; // 符号大小 size in bytes } Elf64_Symbol; 符号表解析 链接器解析符号的方法 是 把每个引用与它输入的可重定位目标文件的符号表中的一个确定符合定义关联起来。 对于 引用和定义在相同模块内的局部符号引用，符号解析很简单。 对于全局符号解析，如果 遇到了一个不在当前模块定义的符号(变量或函数名)，会假设这个符号是在其他某个模块中定义的，并生成一个链接器符号表，交给链接器来处理。 如果链接器在所有模块内都找不到被引用的符号，就会输出错误信息被终止。 Linux 链接器解析全局符号的规则： 不允许有多个同名的强符号 如果有一个强符号和多个弱符号同名，则则选择强符号 若果有多个弱符号同名，则随机选择一个 强符号：函数和已初始化的全局变量 弱符号：未初始化的全局变量 静态库链接 将部分相关的目标模块打包成一个单独的文件，成为静态库(static library)。 当链接器构造一个输出的可执行文件时，它只复制静态库中被应用程序引用的目标模块。 在Linux系统中，静态库以一种称为 存档(archive)的特殊文件格式粗放在磁盘中。 存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的位置和大小。 存档文件由后缀 .a 标识。 一个坑：在链接时，静态库一般放在命令行结尾。被依赖的库必须放在依赖它的后面链接。 重定位 完成符号解析后，代码中的每个符号引用和符号定义关联起来了。接下来要重定位，合并输入模块，并为每个符号重新分配地址。 重定位分两步： 重定位Section和符号定义。 链接器将所有的相同类型的Section合并成一个，然后根据符号新的地址修改符号表中符号定义的信息(section、value等)。此时，程序中的每个符号(函数和全局变量)都有唯一的运行时内存地址了。 重定位section中的符号引用。 链接器修改 代码节和数据节中对每个符号的引用，使他们指向正确的运行时地址。 重定位条目 代码的重定位条目放在 .rel.text 中，已初始化数据的重定位条目放在 .rel.data 中 动态链接共享库 共享库(dynamic linking shared library)是一个目标模块，在加载或运行时，可以加载到内存中，并和一个程序链接起来。 不同系统的动态库： Linux 为 .so 文件 Windows 为 .ddl 文件 Mac 问 .dylib 文件 iOS中动态库 dylib 参考 在运行时，虚拟内存会把 segment 映射到进程的地址空间，按需加载(mmap技术) "},"ios/basic/macho.html":{"url":"ios/basic/macho.html","title":"Mach-O","keywords":"","body":"Mach-O文件 概览： Fat Binary Header 描述了 包括的arc 类型 头部信息 mach_header struct mach_header { uint32_t magic; cpu_type_t cputype; cpu_subtype_t cpusubtype; uint32_t filetype; uint32_t ncmds; uint32_t sizeofcmds; uint32_t flags; }; magic 表示大端还是小端 #define MH_MAGIC 0xfeedface //小端保存的32位文件 #define MH_CIGAM 0xcefaedfe //大端保存的32位文件 #define MH_MAGIC_64 0xfeedfacf //小端保存的64位文件 #define MH_CIGAM_64 0xcffaedfe //大端保存的64位文件 #define FAT_MAGIC 0xcafebabe //小端保存的FAT文件 #define FAT_CIGAM 0xbebafeca //大端保存的FAT文件 cputype cpu类型 CPU_TYPE_I386 => :i386, CPU_TYPE_X86_64 => :x86_64, CPU_TYPE_ARM => :arm, CPU_TYPE_ARM64 => :arm64, cpusubtype 具体的CPU类型，区分不同版本的处理器 filetype MH_OBJECT => :object, MH_EXECUTE => :execute, MH_DYLIB => :dylib, ncmds number of load commands sizeofcmds size of load commands 更多参考：https://www.rubydoc.info/github/Homebrew/ruby-macho/MachO Load Commands 中保存了所有 Segment 和 dylib 的信息。 Segment 一个 command 中保存的一个 segment 数据如下： struct segment_command { /* for 32-bit architectures */ // LC_SEGMENT 或 LC_SEGMENT_64 uint32_t cmd; /* LC_SEGMENT */ uint32_t cmdsize; /* includes sizeof section structs */ // 名称 char segname[16]; /* segment name */ // 段虚拟地址 uint32_t vmaddr; /* memory address of this segment */ // 段大小 uint32_t vmsize; /* memory size of this segment */ uint32_t fileoff; /* file offset of this segment */ uint32_t filesize; /* amount to map from the file */ vm_prot_t maxprot; /* maximum VM protection */ vm_prot_t initprot; /* initial VM protection */ // 该segment 中 section 个数 uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */ }; struct segment_command_64 { /* for 64-bit architectures */ uint32_t cmd; /* LC_SEGMENT_64 */ uint32_t cmdsize; /* includes sizeof section_64 structs */ char segname[16]; /* segment name */ uint64_t vmaddr; /* memory address of this segment */ uint64_t vmsize; /* memory size of this segment */ uint64_t fileoff; /* file offset of this segment */ uint64_t filesize; /* amount to map from the file */ vm_prot_t maxprot; /* maximum VM protection */ vm_prot_t initprot; /* initial VM protection */ uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */ }; Section struct section { /* for 32-bit architectures */ char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint32_t addr; /* memory address of this section */ uint32_t size; /* size in bytes of this section */ uint32_t offset; /* file offset of this section */ uint32_t align; /* section alignment (power of 2) */ uint32_t reloff; /* file offset of relocation entries */ uint32_t nreloc; /* number of relocation entries */ uint32_t flags; /* flags (section type and attributes)*/ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */ }; struct section_64 { /* for 64-bit architectures */ char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint64_t addr; /* memory address of this section */ uint64_t size; /* size in bytes of this section */ uint32_t offset; /* file offset of this section */ uint32_t align; /* section alignment (power of 2) */ uint32_t reloff; /* file offset of relocation entries */ uint32_t nreloc; /* number of relocation entries */ uint32_t flags; /* flags (section type and attributes)*/ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */ uint32_t reserved3; /* reserved */ }; 解析步骤 线解析mach_header先判断magic头如果是大端的记得每一个结构都得转小段 跟据mach_header.sizeofcmds确定load commands的范围为sizeof(mach_header) 然后跟据mach_header.ncmds读取 先使用load command简化结构预读取 判断cmd与cmdsize再使用完整结构读取 如果解析segment则跟据nsects来读取segment下的section section数据跟随在对应的segment结构后面单section对应的数据不一定跟随在section后面 跟据section的offset,size,flags来解析对应的数据 Mach-O 中的 segment 一个目标文件中包含不同区域，每个区域被称为 segment __TEXT 权限：只读，可执行。 __text 代码节，存放机器编译后的代码 __stubs 符号桩。本质上是一小段会直接跳入 lazybinding 的表对应项指针指向的地址的代码 用于辅助做动态链接代码（dyld） __stub_helper 辅助函数。上述提到的lazybinding的表中对应项的指针在没有找到真正的符号地址的时候，都指向这 用于辅助做动态链接（dyld） __cstring 去重后的c字符串 __objc_classname objc 类名 __objc_methoname objc 方法名称 __objcmethtype objc 方法类名 __gcc_except_tab // __const __swift4_typeref __swift4_fieldmd __swift4_types __entitlements __unwind_info __DATA 权限：可读写、不可执行 __data __bss 存储未初始化的静态量。比如：`static NSThread *_networkRequestThread = nil;`其中这里面的size表示应用运行占用的内存，不是实际的占用空间。所以计算大小的时候应该去掉这部分数据。 __common 存储导出的全局的数据。类似于static，但是没有用static修饰。比如KSCrash里面`NSDictionary* g_registerOrders;`, g_registerOrders就存储在__common里面 __objc_nlclslist Objective-C 的 +load 函数列表，比 __mod_init_func 更早执行 __objc_data __objc_ivar ivar 指针，存储属性 __objc_superrefs objc的超类 __objc_classrefs __objc_selrefs 引用到的objc方法 __objc_const objc常量。保存objc_classdata结构体数据。用于映射类相关数据的地址，比如类名，方法名等 __objc_imageinfo 镜像信息 __objc_protolist objc 协议 __objc_classlist __cfstring __const __got 存储引用符号的实际地址，类似于动态符号表，存储了`__nl_symbol_ptr`相关函数指针 __la_symbol_ptr 懒加载的函数指针地址（C代码实现的函数对应实现的地址）。和__stubs和stub_helper配合使用 __nl_symbol_ptr __mod_init_func 模块初始化的方法。 __LINKEDIT 含了加载程序的『元数据』，比如函数的名称和地址。只读（r–） 包含需要被动态链接器使用的信息，包括符号表、字符串表、重定位项表等 Load Command 记录 如何加载每个 section 的信息 __PAGEZERO Catch访问NULL指针的非法操作的段 参考： https://satanwoo.github.io/2017/06/13/Macho-1/ https://satanwoo.github.io/2017/06/29/Macho-2/ https://dlnn.net/2017/07/05/macho%E6%96%87%E4%BB%B6%E9%83%A8%E5%88%86%E8%A7%A3%E6%9E%90/ "},"ios/basic/signature.html":{"url":"ios/basic/signature.html","title":"签名流程","keywords":"","body":"签名流程 "},"ios/basic/linkmap.html":{"url":"ios/basic/linkmap.html","title":"LinkMap文件","keywords":"","body":"LinkMap 文件 如何生成 LinkMap 文件 1. 在XCode中开启编译选项Write Link Map File XCode -> Project -> Build Settings -> 把Write Link Map File选项设为yes，并指定好linkMap的存储位置 2.工程编译完成后，在编译目录里找到Link Map文件（txt类型） 默认的文件地址：~/Library/Developer/Xcode/DerivedData/XXX-xxxxxxxxxxxxx/Build/Intermediates/XXX.build/Debug-iphoneos/XXX.build/ LinkMap文件包含3部分： 1.Object Files 这部分内容都是 .m文件编译后的.o文件和需要link的.a文件。签名是文件编号，后面是文件路径。 # Object files: [ 0] linker synthesized [ 1] /Users/hour/Library/Developer/Xcode/DerivedData/TestObjC-ehiipviorxrstxesehwsodphwccc/Build/Intermediates.noindex/TestObjC.build/Debug-iphonesimulator/TestObjC.build/TestObjC.app-Simulated.xcent [ 2] /Users/hour/Library/Developer/Xcode/DerivedData/TestObjC-ehiipviorxrstxesehwsodphwccc/Build/Intermediates.noindex/TestObjC.build/Debug-iphonesimulator/TestObjC.build/Objects-normal/x86_64/HelloWorld.o [ 3] /Users/hour/Library/Developer/Xcode/DerivedData/TestObjC-ehiipviorxrstxesehwsodphwccc/Build/Intermediates.noindex/TestObjC.build/Debug-iphonesimulator/TestObjC.build/Objects-normal/x86_64/ViewController.o 等等 [ 10] /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator12.1.sdk/System/Library/Frameworks//UIKit.framework/UIKit.tbd 2.Sections 这里描述的是每个 Section 在可执行文件中的位置和大小。每个 Section 的 Segment 分为 TEXT代码段 和 DATA数据段 两种类型 格式： struct Section { Address Size Segment Section } Demo: # Sections: # Address Size Segment Section 0x100001450 0x00000567 __TEXT __text 0x1000019B8 0x0000004E __TEXT __stubs 0x100001A08 0x00000092 __TEXT __stub_helper 0x100001A9A 0x000000B0 __TEXT __cstring 0x100001B4A 0x0000004F __TEXT __objc_classname 0x100001B99 0x00000A2D __TEXT __objc_methname 0x1000025C6 0x0000086D __TEXT __objc_methtype 0x100002E33 0x00000178 __TEXT __entitlements 0x100002FAC 0x00000048 __TEXT __unwind_info 0x100003000 0x00000010 __DATA __nl_symbol_ptr 0x100003010 0x00000018 __DATA __got 0x100003028 0x00000068 __DATA __la_symbol_ptr 0x100003090 0x00000030 __DATA __const 0x1000030C0 0x00000040 __DATA __cfstring 0x100003100 0x00000020 __DATA __objc_classlist 0x100003120 0x00000010 __DATA __objc_protolist 0x100003130 0x00000008 __DATA __objc_imageinfo 0x100003138 0x00000D48 __DATA __objc_const 0x100003E80 0x00000010 __DATA __objc_selrefs 0x100003E90 0x00000008 __DATA __objc_classrefs 0x100003E98 0x00000008 __DATA __objc_superrefs 0x100003EA0 0x00000008 __DATA __objc_ivar 0x100003EA8 0x00000140 __DATA __objc_data 0x100003FE8 0x000000C0 __DATA __data 3.Symbols Symbols 对 Section 进行了再划分。这里会描述所有的 methods、ivar和字符串等对应的地址、大小、文件编号信息。 格式： struct Symbol { Address Size File Name } Demo： # Symbols: # Address Size File Name 0x100001450 0x00000027 [ 2] -[HelloWorld hello] 0x100001480 0x00000040 [ 3] -[ViewController viewDidLoad] 0x1000014C0 0x00000027 [ 3] -[MyClass hello] 0x1000014F0 0x00000092 [ 4] _main 0x100001590 0x00000080 [ 5] -[AppDelegate application:didFinishLaunchingWithOptions:] 0x100001610 0x00000040 [ 5] -[AppDelegate applicationWillResignActive:] ... 查看 LinkMap 文件的工具 下载地址： https://github.com/quding0308/LinkMap 其他参考： https://github.com/778477/iOS-LinkMapAnalyzer http://zwgeek.com/2018/01/08/%E5%9F%BA%E4%BA%8ELinkMap%E5%88%86%E6%9E%90iOSAPP%E5%90%84%E6%A8%A1%E5%9D%97%E4%BD%93%E7%A7%AF/ https://blog.cnbang.net/tech/2296/ "},"ios/basic/c.html":{"url":"ios/basic/c.html","title":"C语言","keywords":"","body":"c语言 Xcode 中默认使用的是 gun11 国际标准组织发布c11后，gnu为自己的编译器发布两种标准gnu11和c11 gnu11：带gnu c扩展的c11标准，如果你的代码包含了typeof，__attribute__等等gnu的扩展，就必须用这个。 c11：这个就是纯c11的标准，不带gnu扩展。 -std=gnu11 "},"other/ios_network.html":{"url":"other/ios_network.html","title":"iOS 网络相关","keywords":"","body":"iOS 网络相关 URLSession URLSession URLSessionConfiguration URLSessionTask URLSessionDataTask URLSessionDownloadTask URLSessionUploadTask URLSessionStreamTask URLSessionTask 中包含： URLRequest URLResponse HTTPURLResponse Demo #import @interface MyNetworkTest () @property (nonatomic, strong) NSURLSession *urlSession; @end @implementation MyNetworkTest - (void)start { NSURL *url = [NSURL URLWithString:@\"https://blog.quding0308.com/\"]; NSURLSessionDataTask *task = [self.urlSession dataTaskWithURL:url]; [task resume]; } - (NSURLSession *)urlSession { if (_urlSession == nil) { NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration]; _urlSession = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:NSOperationQueue.mainQueue]; } return _urlSession; } #pragma mark - NSURLSessionTaskDelegate & NSURLSessionDataDelegate // https 证书校验 session 级别 - (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler { NSLog(@\"=== session didReceiveChallenge\"); NSLog(@\"%@\", challenge.protectionSpace.authenticationMethod); // 1.从服务器返回的受保护空间中拿到证书的类型 // 2.判断服务器返回的证书是否是服务器信任的 if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) { NSLog(@\"是服务器信任的证书\"); // 3.根据服务器返回的受保护空间创建一个证书 // void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential *) // 代理方法的completionHandler block接收两个参数: // 第一个参数: 代表如何处理证书 // 第二个参数: 代表需要处理哪个证书 //创建证书 NSURLCredential *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; // 4.证书 completionHandler(NSURLSessionAuthChallengeUseCredential, credential); } else { // 允许 NSURLSession 使用不安全的 SSL 连接 completionHandler(NSURLSessionAuthChallengePerformDefaultHandling, nil); } } // task 级别 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler { [self URLSession:session didReceiveChallenge:challenge completionHandler:completionHandler]; } // 重定向回调 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task willPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest * _Nullable))completionHandler { NSLog(@\"=== willPerformHTTPRedirection\"); } // 接收到 response header - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler { NSLog(@\"=== didReceiveResponse\"); completionHandler(NSURLSessionResponseAllow); } // 接收到返回的数据 - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data { NSLog(@\"=== didReceiveData\"); } // 数据接收完成，缓存到本地 (当 didReceiveData 调用完成后，如果本地做缓存，则会调用) - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask willCacheResponse:(NSCachedURLResponse *)proposedResponse completionHandler:(void (^)(NSCachedURLResponse * _Nullable cachedResponse))completionHandler { NSLog(@\"=== willCacheResponse\"); completionHandler(proposedResponse); } // 请求完成 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error { NSLog(@\"=== didCompleteWithError\"); } @end AFNetworking AFNetworkReachabilityManager 什么原理？是否可以监听弱网络？ AFNetworking 库中一共有 6 个文件 2 个 SessionManager AFURLSessionManager AFHTTPSessionManager 2 个 Serialization AFURLRequestSerialization AFURLResponseSerialization AFNetworkReachabilityManager AFSecurityPolicy 类关系： AFNetworkReachabilityManager 每次调用 [AFNetworkReachabilityManager manager] 都会创建一个新的实例 AFSecurityPolicy AFSSLPinningMode 有 3 种方式可设置： AFSSLPinningModeNone 默认使用。信任服务器端返回的证书，iOS 系统会校验证书的有效性。 AFSSLPinningModePublicKey 使用指定的 publickey (本地设置证书，然后从证书中读取 publickey 来设置) 针对某一个域名，客户端会将服务器返回的证书中的 publickeys 与本地保存的证书中的 publickey 进行校验。如果两者有交集，则认为校验通过。 AFSSLPinningModeCertificate 针对某一个域名，客户端会将服务器返回的证书 与本地保存的证书 进行校验。如果两者之间有相同的证书，则校验通过。 注意： AFSSLPinningModePublicKey 只比对证书里的 publickey，即使服务器证书有所变动，只要 public key 不变，就能通过验证。如果证书过期了，服务器可以直接更换新证书，只需保证 publickey 不变即可，客户端不需要更新 AFSSLPinningModeCertificate 会对比证书里的所有内容，包括证书的 pubkey、过期时间 等。比 AFSSLPinningModePublicKey 更安全，但是如果证书过期，必须更新客户端，更换证书。 pin 为 大头针， pinned 指固定的，置顶的（用大头针别住了，固定的） 设置证书： 通过 certificatesInBundle:(NSBundle *)bundle 来获取证书，其中 bundle 中所有以 .cer 结尾的证书都会被自动加载。 certificatesInBundle 返回的 Set， 调用 setPinnedCertificates 设置证书 AFSecurityPolicy *policy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModePublicKey]; NSSet *certificates = [AFSecurityPolicy certificatesInBundle:[NSBundle mainBundle]]; [policy setPinnedCertificates:certificates]; 安全策略 allowInvalidCertificates 是否允许无效的证书，是否校验证书的有效性(注意，如果校验证书结果为 kSecTrustResultUnspecified ，也认为可用)。 如果是自建证书，则会被系统认为是无效证书，此属性需要设置为 YES， validatesDomainName 是否需要验证域名。从服务器下载的证书读取包含的domain，然后判断是否包含当前的证书 假如证书的域名与你请求的域名不一致，需把该项设置为NO。 适用情况： 适用 ip 替换了 域名请求，此属性需要设置为 NO 客户端请求的是子域名，而证书上的 是另外一个域名。因为SSL证书上的域名是独立的 鉴权相关 可以针对某域名，单独处理不做 https 的证书校验 [_sessionManager setSessionDidReceiveAuthenticationChallengeBlock:^NSURLSessionAuthChallengeDisposition(NSURLSession * _Nonnull session, NSURLAuthenticationChallenge * _Nonnull challenge, NSURLCredential *__autoreleasing _Nullable * _Nullable credential) { if ([challenge.protectionSpace.host isEqualToString:@\"com.xx.www\"]) { return NSURLSessionAuthChallengePerformDefaultHandling; } else if (credential) { return NSURLSessionAuthChallengeUseCredential; } else { return NSURLSessionAuthChallengePerformDefaultHandling; } }]; 参考 https://juejin.im/post/5a332b6a6fb9a0451e3fd6b0 不安全的https示例 https://badssl.com/ "},"ui/":{"url":"ui/","title":"UI渲染","keywords":"","body":"UI相关 渲染流程 卡顿原因 常见卡顿问题 如何监测卡顿 常见优化点 tableview卡顿优化 文字渲染 为什么容易卡顿？ 加载超大图片 如何优化？ 离屏渲染 为什么容易导致卡顿？ Autolayout 为什么更容易卡顿？关键的点在哪里？ "},"ui/screen.html":{"url":"ui/screen.html","title":"显示器原理","keywords":"","body":"显示器原理 CRT显示器 学名：阴极射线显像管。 是一种使用阴极射线管的显示器。 LCD Liquid Crystal Display 中文：液晶显示器。 Retina 显示屏 就是普通的液晶屏。 显示器显示原理： CRT的电子枪按照上面的方式，上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。 当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync； 而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示 器会发出一个垂直同步信号（vertical synchronization），简称 VSync。 显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。 显示器的VSync频率是固定不变的。 详细介绍： 在操作系统与硬件驱动程序的帮助下，用户通过输入设备或者程序向计算机CPU发送一系列的数据，这些数字信号再经过显卡变为不断变化的电压模拟信号，电压控制了液晶的滤光性，像素背后的白光被分成了强弱不同的三原色光，再经人眼的混色作用使得一个像素具有了千变万化的颜色。 参考 https://zhuanlan.zhihu.com/p/32136704 "},"ui/render.html":{"url":"ui/render.html","title":"render","keywords":"","body":"render ask 屏幕刷新的频率是固定 60 fps，每次屏幕刷新完后通过 V-Sync 机制 切换缓冲区读取新数据。如果 缓存区内的数据没有在16.6 ms内没有刷新，则不切换缓冲区。 所以 每一帧的渲染 我们应该控制在 16.6 ms 内结束。 一帧的渲染流程： CPU 把计算好显示的内容给CPU => GPU 渲染 => 放入缓存区 所以 我们需要在 16.6 ms内 把 CPU 和 GPU 的工作都做完 CPU 在主线程的一个 runloop 周期内 做渲染相关的工作，所以我们应该在主线程中尽量减少耗时操作，保证 runloop 在 16.6 ms内执行完。 GPU 比较高效，我们重点是优化 CPU CPU 优化思路： 1. 减少 主线程中 执行的任务 2. 渲染中的 需要做的部分工作 可以放到 子线程中执行(YYAsyncLayer) 另外：控制子线程的数量，保证 主线程 优先执行(不重要) CPU、GPU、显示器如何一起工作 CPU计算好显示的内容提交给GPU GPU渲染完后将渲染结果放入帧缓冲区 视频控制器(显卡) 按照HSync 和 VSync信号读取帧缓冲区数据，传递给显示器 双缓冲区机制 帧缓冲区有两个：Buffer1 + Buffer2 双缓冲区要解决的问题： GPU渲染好一帧后就更新缓冲区(视频控制器指向了另一个缓冲区)。但此时显示器可能只刷新了半屏幕的数据，更新缓存区后，会从新的缓冲区读取数据，会导致一个屏幕内的数据来源于两个缓冲区，导致画面撕裂。 GPU的垂直同步机制（V-Sync机制）解决双缓冲区的问题： GPU渲染好一帧放入一个缓冲区，由视频控制器读取。 当显示器把Buffer1的内容绘制到屏幕后，会发送VSync信号。视频控制器会从Buffer1切换到Buffer2，继续绘制Buffer2的内容。当App进程收到VSync信号后，开始绘制下一帧内容到Buffer1。 绘制一帧的过程 如果在一个VSync周期内 CPU + GPU 渲染没有结束，则会丢弃这一帧的绘制结果，重新绘制下一帧。此时就发生了 “掉帧” CPU渲染 -> GPU渲染 -> 结果放到buffer中 显示器的VSync信号到来后，iOS系统会通过CADisplayLink机制通知App App的主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区Buffer1。当下一次 VSync 信号到来时，会Buffer1的内容显示到屏幕上，在Buffer2中渲染下一帧的内容。 iOS中卡顿原因： 如果在一个VSync周期内，下一帧的内容没有渲染到Buffer中，则这一帧就会被丢弃，显示器会保留之前的内容不变。给用户的感觉就是 “卡顿” 在一帧的渲染过程中，不管CPU 和 GPU 哪个阻碍了显示流程，都会造成卡顿。所以需要分别考虑优化CPU和GPU的渲染过程。 CPU渲染 优化思路： 减少 主线程中 执行的任务 跟渲染不相关的任务、耗时任务 放到子线程执行 把图片放到 Assert 中，提升图片解码效率(解压缩时，CPU 峰值至少能降低 3倍) UI 渲染相关的计算结果，缓存复用 tableView 的高度 缓存复用（fd） 富文本 AttributedString 缓存复用 使用 Diff 算法，减少 tableView 的刷新工作量 渲染中的 需要做的部分工作 可以放到子线程中执行 YYAsyncLayer AsyncDisplayKit 只关注当前显示的UI，停止屏幕之外的UI刷新 避免离屏渲染 当页面滚动时，减少 渲染的工作 tableView减速或停止时，再刷新当前屏幕的UI(VVTableView) CPU消耗的资源(2+2+2)： 对象创建、调整、销毁 布局计算 Autolayout 文本的宽高计算 文本渲染 图片的解码 绘制 drawRect CG开头的绘制 优化思路 尽量少用 alpha。如果一个图片有透明通道，但是不需要实现透明效果，可以使用 opaque=yes 关闭透明通道渲染。 减少离屏渲染 layer.mask layer.cornerRadius layer.shadows GPU消耗： 纹理的渲染 视图的混合 图形的生成 大概优化思路 尽量减少主线程中的工作，放到子线程执行 多使用缓存，减少计算 更新时，只更新有变化的内容 (RXDataSource的思路) 参考： Autolayout 渲染优化：https://juejin.im/post/5bd5a546f265da0af033cee6 https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#32 https://zhuanlan.zhihu.com/p/35693019 https://mp.weixin.qq.com/s/rpACR4W8fvt8pRGyn1oxeA "},"ui/cpu.html":{"url":"ui/cpu.html","title":"cpu渲染","keywords":"","body":"优化思路 尽量减少主线程中的工作，放到子线程执行 iPhone的CPU目前都是多核(A10 4核，A11 6核，A12 6核)。 而主线程只能在一个核上跑，在App卡顿时，其他核往往无事可做。 一般情况下，由于主线程承担了绝大部分的工作，仅仅是把主线程的任务转移一部分给其他线程进行异步处理，就可以马上享受到并发带来的性能提升。 优化的思路之一 【尽量减少主线程中的工作，放到子线程执行】 卡顿的判断 主要是 用户与App交互时是否会卡住。例如 滑动页面时时 是否流畅，点击按钮后是否会立即有反应。 多使用缓存，减少计算 更新时，只更新有变化的内容 (RXDataSource的思路) 控件初始化 view创建消耗性能 使用懒加载，创建任务分开 直接使用代码创建会比storyboard创建更快 尽量使用轻量的控件。例如 layer代替view Autolayout 性能瓶颈 自动布局是在主线程执行的。 图片解压 图片加载 图片渲染 文字渲染 调整对象文本计算 优化方案： 文本的宽高计算，做缓存， 在后台线程绘制 用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本，记住放到后台线程进行以避免阻塞主线程。 布局计算 调整对象层次和布局 视图布局的计算比较消耗cpu，可以使用缓存减少计算，以及不要频繁的计算和调整 实际案例 聊天页面 使用 RXDataSource 帖子页面 提前计算缓存cell的layout 缓存 attributedString的渲染 异步渲染layer YYAsyncLayer 滑动时 省去中间过程的计算，直接计算目标区域的cell "},"ui/gpu.html":{"url":"ui/gpu.html","title":"gpu渲染","keywords":"","body":"离屏渲染 On Screen Render 当前屏幕渲染。指GPU渲染的操作是在屏幕缓冲区中进行。 Off Screen Render 离屏渲染。指GPU渲染操作 在屏幕缓冲区之外新开辟一个缓冲区进行渲染。 注意：Core Graphics 使用CPU绘制，渲染成bitmap后，交由 GPU 显示。 优化：Core Graphics 可以异步绘制，绘制完成后，显示的时候放回主线程。 dispatch_async(backgroundQueue, ^{ CGContextRef ctx = CGBitmapContextCreate(...); // draw in context... CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^{ layer.contents = img; }); }); 触发离屏渲染 shouldRasterize（光栅化）设置为 YES masks 遮罩 shadows 阴影 edge antialiasing 抗锯齿 group opacity 半透明 cornerRadius 圆角 渐变 shouldRasterize（光栅化） When the value of this property is true, the layer is rendered as a bitmap in its local coordinate space and then composited to the destination with any other content. Shadow effects and any filters in the filters property are rasterized and included in the bitmap. 为什么会有离屏渲染 含有透明度的视图，在显示前需要进行图层的合成，即对重叠视图的每个像素的 R，G，B，A 值进行重计算，最终显示组合的效果。 Instruments监测离屏渲染 Instruments的Core Animation工具中有几个和离屏渲染相关的检查选项： Color Offscreen-Rendered Yellow 开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。 Color Hits Green and Misses Red 如果shouldRasterize被设置成YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。 参考 http://www.10tiao.com/html/585/201803/2654061295/1.html "},"ui/layout.html":{"url":"ui/layout.html","title":"layout","keywords":"","body":"布局更新 layoutSubviews 此方法用来重新定义子元素的位置和大小。当子类重写此方法，用来实现UI元素的更精确布局。 很多时候系统会自动调用layoutSubviews方法： view init初始化时不会调动，在 addSubview 时会触发layoutSubviews view 的 frame 有变化时会触发 直接修改frame 或 center 使用 Autolayout (实际也是调整了view的frame) UIScrollView 滚动时会触发 屏幕旋转会触发 setNeedsLayout 标记需要更新layout。保证在下次调用layoutIfNeede时会调用 layoutSubviews。 Call this method on your application’s main thread when you want to adjust the layout of a view’s subviews. This method makes a note of the request and returns immediately. Because this method does not force an immediate update, but instead waits for the next update cycle, you can use it to invalidate the layout of multiple views before any of those views are updated. This behavior allows you to consolidate all of your layout updates to one update cycle, which is usually better for performance. setNeedsLayout makes sure a future call to layoutIfNeeded calls layoutSubviews. layoutIfNeeded 强制立刻刷新layout，需要首先调用 setNeedsLayout。 setNeedsDisplay 调用 setNeedsDisplay 后，系统会在在下次渲染过程中调用 drawRect: 重新绘制。 You can use this method or the setNeedsDisplayInRect: to notify the system that your view’s contents need to be redrawn. 示例：http://blog.fujianjin6471.com/2015/06/11/An-example-of-when-should-setNeedsDisplay-be-called.html 参考： https://stackoverflow.com/questions/20609206/setneedslayout-vs-setneedsupdateconstraints-and-layoutifneeded-vs-updateconstra "},"ui/response-chain.html":{"url":"ui/response-chain.html","title":"响应链","keywords":"","body":"responder & responder-chain to handle events 从 UIWindow 逐层往里传递 优先最内部View响应，通过 hintTest:point,:event 确定 当前的view是否响应 keyWindow可以响应event 手势如何处理？ responder UIResponder 的子类 都可以响应 UIEvent，包括 UIView、UIViewController、UIWindow、UIApplication FirstResponder 可以响应event UIResponder *next = [self nextResponder]; BOOL can1 = [self canBecomeFirstResponder]; [self becomeFirstResponder]; BOOL can2 = [self canResignFirstResponder]; [self resignFirstResponder]; BOOL isFirstResponder = [self isFirstResponder]; 当App接收到event，UIKit会自动 把event传递给合适的responder。如上图，点击输入框后首先会传递给UITextField，如果不响应 会继续传递给super view，直到找到相应的responder，最后到AppDelegate。 UIEvent UIEvent type： touch event press event shake-motion event remote-control event editing menu message hitTest:withEvent: view 通过 hitTest:withEvent: 确定是否作为first reponder。 hitTest:withEvent: 从view 层级的最顶部(最上层)开始逐个判断，是否能处理event。加入能处理，则该view 就是 first responder Gesture 如何处理？ Gesture recognizers receive touch and press events before their view does. If a view's gesture recognizers fail to recognize a sequence of touches, UIKit sends the touches to the view. If the view does not handle the touches, UIKit passes them up the responder chain. 给view添加的gesture会优先获取到touch和press event，假如gesture没有处理，则event 传递给view，进入responder chain 可以给一个viewattach 多个Gesture。系统会根据用户的交互 看是否满足某个gesture pattern。如果 match 某个gesture，则调用gesture绑定的target。如果没有match gesture，则该event会进入 responder chain 手势包括： UITapGestureRecognizer UIPinchGestureRecognizer UIRotationGestureRecognizer UISwipeGestureRecognizer UIPanGestureRecognizer UIScreenEdgePanGestureRecognizer // 发生在屏幕边缘的pan gesture UILongPressGestureRecognizer 多手势如何处理？ UIGestureRecognizerDelegate //开始进行手势识别时调用的方法，返回NO则结束识别，不再触发手势，用处：可以在控件指定的位置使用手势识别 - (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer; //设置点击的范围 - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch{ //获取当前的触摸点 CGPoint curp = [touch locationInView:self.imageView]; if (curp.x 参考 官网 https://www.cnblogs.com/wujy/p/5821991.html https://juejin.im/post/5b1cf9f0e51d4506af2e9ba0 所以 loading 可以做成window 或者 单独的view添加 设置层 不响应 event "},"ui/image-render.html":{"url":"ui/image-render.html","title":"图片解压缩","keywords":"","body":"Image 加载流程 - (void)testImageLoad { [self.view addSubview:self.imgView]; [self.imgView mas_makeConstraints:^(MASConstraintMaker *make) { make.top.mas_equalTo(self.view).mas_offset(40); make.left.mas_equalTo(self.view); make.width.height.mas_equalTo(50); }]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ // 此时图片并没有解压缩 // 系统实际上只是在 Bundle 内查找到文件名，然后把这个文件名放到 UIImage 里返回，并没有进行实际的文件读取和解码。 UIImage *img = [UIImage imageNamed:@\"image\"]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ // 赋值时，开始从磁盘读取图片文件，解压缩，渲染图层 self.imgView.image = img; }); }); } 将生成的 UIImage 赋值给 UIImageView 后执行的流程： 一个隐式的 CATransaction 捕获到了 UIImageView 图层树的变化 在主线程的下一个 run loop 到来时，Core Animation 提交了这个隐式的 transaction，读取图片文件，渲染： 分配内存缓冲区用于管理文件 IO 和解压缩操作 将文件数据从磁盘读到内存中 将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的 CPU 操作 最后 Core Animation 使用未压缩的位图数据渲染 UIImageView 的图层 在子线程中强制解压缩生成image 图片解压缩的过程其实就是将图片的二进制数据转换成像素数据的过程。 位图就是一个像素数组，数组中的每个像素就代表着图片中的一个点。我们在应用中经常用到的 JPEG 和 PNG 图片就是位图。 解压缩后的图片大小 = 图片的像素宽 30 图片的像素高 30 每个像素所占的字节数 4 原理：使用绘制的接口，把image 在子线程中绘制到context中，然后生成image，即完成解压缩过程。 CGImageRef YYCGImageCreateDecodedCopy(CGImageRef imageRef, BOOL decodeForDisplay) { ... if (decodeForDisplay) { // decode with redraw (may lose some precision) CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(imageRef) & kCGBitmapAlphaInfoMask; BOOL hasAlpha = NO; if (alphaInfo == kCGImageAlphaPremultipliedLast || alphaInfo == kCGImageAlphaPremultipliedFirst || alphaInfo == kCGImageAlphaLast || alphaInfo == kCGImageAlphaFirst) { hasAlpha = YES; } // BGRA8888 (premultiplied) or BGRX8888 // same as UIGraphicsBeginImageContext() and -[UIView drawRect:] CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host; bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst; // 1. 创建上下文 CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, YYCGColorSpaceGetDeviceRGB(), bitmapInfo); if (!context) return NULL; // 2. 将原始位图绘制到上下文中 CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); // decode // 创建一张新的解压缩后的位图 CGImageRef newImage = CGBitmapContextCreateImage(context); CFRelease(context); return newImage; } else { ... } } 在 SD 中对应的实现 在 #import \"SDWebImageDecoder.h\" + (nullable UIImage *)decodedImageWithImage:(nullable UIImage *)image { if (![UIImage shouldDecodeImage:image]) { return image; } // autorelease the bitmap context and all vars to help system to free memory when there are memory warning. // on iOS7, do not forget to call [[SDImageCache sharedImageCache] clearMemory]; @autoreleasepool{ CGImageRef imageRef = image.CGImage; CGColorSpaceRef colorspaceRef = [UIImage colorSpaceForImageRef:imageRef]; size_t width = CGImageGetWidth(imageRef); size_t height = CGImageGetHeight(imageRef); size_t bytesPerRow = kBytesPerPixel * width; // kCGImageAlphaNone is not supported in CGBitmapContextCreate. // Since the original image here has no alpha info, use kCGImageAlphaNoneSkipLast // to create bitmap graphics contexts without alpha info. CGContextRef context = CGBitmapContextCreate(NULL, width, height, kBitsPerComponent, bytesPerRow, colorspaceRef, kCGBitmapByteOrderDefault|kCGImageAlphaNoneSkipLast); if (context == NULL) { return image; } // Draw the image into the context and retrieve the new bitmap image without alpha CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); CGImageRef imageRefWithoutAlpha = CGBitmapContextCreateImage(context); UIImage *imageWithoutAlpha = [UIImage imageWithCGImage:imageRefWithoutAlpha scale:image.scale orientation:image.imageOrientation]; CGContextRelease(context); CGImageRelease(imageRefWithoutAlpha); return imageWithoutAlpha; } } 流程： CGBitmapContextCreate -> CGContextDrawImage -> CGBitmapContextCreateImage 图片做压缩，去掉 alpha 通道 在 SD 中，无法在子线程解压带有 alpha 通道的图片 参考 http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/ https://www.jianshu.com/p/e9843d5b70a2 "},"ui/richtext.html":{"url":"ui/richtext.html","title":"富文本","keywords":"","body":"富文本 涉及到 NSMutableAttributedString 和 CoreText NSAttributedString NSMutableParagraphStyle 对应文本中段落，可还是在的属性包括： // 行间距 @property (NS_NONATOMIC_IOSONLY) CGFloat lineSpacing; // 段落间距 @property (NS_NONATOMIC_IOSONLY) CGFloat paragraphSpacing; // 水平对齐方式 @property (NS_NONATOMIC_IOSONLY) NSTextAlignment alignment; // 首行缩进 @property (NS_NONATOMIC_IOSONLY) CGFloat firstLineHeadIndent; // 整体缩进 @property (NS_NONATOMIC_IOSONLY) CGFloat headIndent; @property (NS_NONATOMIC_IOSONLY) CGFloat tailIndent; // 换行模式 @property (NS_NONATOMIC_IOSONLY) NSLineBreakMode lineBreakMode; @property (NS_NONATOMIC_IOSONLY) CGFloat minimumLineHeight; @property (NS_NONATOMIC_IOSONLY) CGFloat maximumLineHeight; @property (NS_NONATOMIC_IOSONLY) NSWritingDirection baseWritingDirection; @property (NS_NONATOMIC_IOSONLY) CGFloat lineHeightMultiple; // 段落前间距 @property (NS_NONATOMIC_IOSONLY) CGFloat paragraphSpacingBefore; @property (NS_NONATOMIC_IOSONLY) float hyphenationFactor; Attibutes 设置 @{ NSForegroundColorAttributeName : UIColor.whiteColor, NSFontAttributeName : [UIFont systemFontOfSize:smallSize], NSParagraphStyleAttributeName : paragraphStyle2, NSKernAttributeName : @(-0.3f) }; NSAttributedString中可设置的字符属性 NSString *const NSFontAttributeName;(字体) NSString *const NSParagraphStyleAttributeName;(段落) NSString *const NSForegroundColorAttributeName;(字体颜色) NSString *const NSBackgroundColorAttributeName;(字体背景色) NSString *const NSLigatureAttributeName;(连字符) NSString *const NSKernAttributeName;(字间距) NSString *const NSStrikethroughStyleAttributeName;(删除线) NSString *const NSUnderlineStyleAttributeName;(下划线) NSString *const NSStrokeColorAttributeName;(边线颜色) NSString *const NSStrokeWidthAttributeName;(边线宽度) NSString *const NSShadowAttributeName;(阴影)(横竖排版) NSString *const NSVerticalGlyphFormAttributeName; 常量 1> NSFontAttributeName(字体) 该属性所对应的值是一个 UIFont 对象。该属性用于改变一段文本的字体。如果不指定该属性，则默认为12-point Helvetica(Neue)。 2> NSParagraphStyleAttributeName(段落) 该属性所对应的值是一个 NSParagraphStyle 对象。该属性在一段文本上应用多个属性。如果不指定该属性，则默认为 NSParagraphStyle 的defaultParagraphStyle 方法返回的默认段落属性。 3> NSForegroundColorAttributeName(字体颜色) 该属性所对应的值是一个 UIColor 对象。该属性用于指定一段文本的字体颜色。如果不指定该属性，则默认为黑色。 4> NSBackgroundColorAttributeName(字体背景色) 该属性所对应的值是一个 UIColor 对象。该属性用于指定一段文本的背景颜色。如果不指定该属性，则默认无背景色。 5> NSLigatureAttributeName(连字符) 该属性所对应的值是一个 NSNumber 对象(整数)。连体字符是指某些连在一起的字符，它们采用单个的图元符号。0 表示没有连体字符。1 表示使用默认的连体字符。2表示使用所有连体符号。默认值为 1（注意，iOS 不支持值为 2）。 6> NSKernAttributeName(字间距) 该属性所对应的值是一个 NSNumber 对象(整数)。字母紧排指定了用于调整字距的像素点数。字母紧排的效果依赖于字体。值为 0 表示不使用字母紧排。默认值为0。 7> NSStrikethroughStyleAttributeName(删除线) 该属性所对应的值是一个 NSNumber 对象(整数)。该值指定是否在文字上加上删除线，该值参考“Underline Style Attributes”。默认值是NSUnderlineStyleNone。 8> NSUnderlineStyleAttributeName(下划线) 该属性所对应的值是一个 NSNumber 对象(整数)。该值指定是否在文字上加上下划线，该值参考“Underline Style Attributes”。默认值是NSUnderlineStyleNone。 9> NSStrokeColorAttributeName(边线颜色) 该属性所对应的值是一个 UIColor 对象。如果该属性不指定（默认），则等同于 NSForegroundColorAttributeName。否则，指定为删除线或下划线颜色。更多细节见“Drawing attributedstrings that are both filled and stroked”。 10> NSStrokeWidthAttributeName(边线宽度) 该属性所对应的值是一个 NSNumber 对象(小数)。该值改变描边宽度（相对于字体size 的百分比）。默认为 0，即不改变。正数只改变描边宽度。负数同时改变文字的描边和填充宽度。例如，对于常见的空心字，这个值通常为3.0。 11> NSShadowAttributeName(阴影) 该属性所对应的值是一个 NSShadow 对象。默认为 nil。 12> NSVerticalGlyphFormAttributeName(横竖排版) 该属性所对应的值是一个 NSNumber 对象(整数)。0 表示横排文本。1 表示竖排文本。在 iOS 中，总是使用横排文本，0 以外的值都未定义。 TextKit NSTextContainer NSTextContainer 定义了文字排版的区域，一般是定义一个矩形的区域，但是可以创建一个它的子类来自定义各种类型的区域，除此之外，还可以设置一组Bezier Paths来实现绕排效果。 NSTextStorage NSTextStorage 是 NSMutableAttributedString 的一个子类，它的作用是存储着字符和属性，被文本系统操作着。除了存储字符，它还管理着所有的排版的对象(NSLayoutManager)，当字符或属性发生改变的时候会通知排版的对象重新排版。 NSLayoutManager 它把所有文本处理的对象协调起来，转换NSTextStorage中存储的文本渲染出来，映射字符到字形，并排版到NSTextContainer指定的区域里去。 一个 NSLayoutManager 使用 NSTextContainer 去决定 在哪里换行，布局部分文本 NSLayoutManger 对象主要会执行这些操作： 控制 text storage 和 text container 对象 转换字符到字型 计算字符位置和存储的信息 管理字符和字型的range 绘制字型到文本窗口 计算一行排版的边框 控制连字符 控制字符字形属性 参考 https://juejin.im/post/5a24afd3f265da431e16968f YYText: https://github.com/ibireme/YYText https://www.jianshu.com/p/e988d2030a08 "},"ui/CALayer.html":{"url":"ui/CALayer.html","title":"CALayer子类","keywords":"","body":"CALayer 子类 CATiledLayer CATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。 把大图片 切分成小图片。然后 按需加载 小图片。 CAScrollLayer CATextLayer 使用 Core Text 绘制文本。 具体使用跟 UILabel 类似 textLayer.string = text; textLayer.contentsScale = [UIScreen mainScreen].scale; CAOpenGLLayer CAEmitterLayer 高性能粒子引擎，用于创建 烟雾，火，雨等效果 CAGradientLayer 生成两种或更多颜色平滑渐变的layer CAShapeLayer 通过矢量图形来绘制图层子类 CATransformLayer 是一个layer group，需要 addSubLayer AVPlayerLayer 播放 视频的layer https://blog.csdn.net/lxl_815520/article/details/51889674 模型 layer 内部维护着三分 layer tree, presentLayer Tree(动画树), modeLayer Tree(模型树) Render Tree (渲染树) 在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentLayer的属性值,而最终展示在界面上的其实是提供 View的 modelLayer 在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display 每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint "},"ui/CoreAnimation.html":{"url":"ui/CoreAnimation.html","title":"CoreAnimation","keywords":"","body":"Core Animation Core Animation provides high frame rates and smooth animations without burdening the CPU and slowing down your app. Most of the work required to draw each frame of an animation is done for you. You configure animation parameters such as the start and end points, and Core Animation does the rest, handing off most of the work to dedicated graphics hardware, to accelerate rendering. Core Animation 自身并不是一个绘图系统。它只是一个负责在硬件上合成和操纵应用内容的 Framework 。 Core Animation 的核心是图层对象，图层对象用于管理和操控你的应用内容。图层将捕获的内容放到一个位图中，图形硬件能够非常容易的操控你的位图。在大部分应用中，图层被作为一种管理视图内容的方式，但是你也可以创建标准的图层，这取决于你自身的需要。 你使用Core Animation创建的大部分动画都包含对图层属性的更改。像视图一样，图层对象也具有边框矩形、坐标原点、尺寸、不透明度、变换矩阵以及许多其他面向可视的属性（如backgroundColor）。大部分这些属性的值发生了变化都将会触发隐式动画被创建。隐式动画是一种从旧属性值动画到新属性值的动画形式。 相关类 CATransaction 事务类,可以对多个layer的属性同时进行修改.它分隐式事务,和显式事务. CAAnimationGroup 允许多个动画同时播放 CABasicAnimation 提供了对单一动画的实现 CAKeyframeAnimation 关键桢动画,可以定义行动路线 CAConstraint 约束类,在布局管理器类中用它来设置属性 CAConstraintLayoutManager 约束布局管理器,是用来将多个CALayer进行布局的.各个CALayer是通过名称来区分,而布局属性是通过CAConstraint来设置的. CATransaction /* Transactions are CoreAnimation's mechanism for batching multiple layer- tree operations into atomic updates to the render tree. Every modification to the layer tree requires a transaction to be part of. * CoreAnimation supports two kinds of transactions, \"explicit\" transactions and \"implicit\" transactions. * Explicit transactions are where the programmer calls `[CATransaction begin]' before modifying the layer tree, and `[CATransaction commit]' afterwards. * Implicit transactions are created automatically by CoreAnimation when the layer tree is modified by a thread without an active transaction. They are committed automatically when the thread's run-loop next iterates. In some circumstances (i.e. no run-loop, or the run-loop is blocked) it may be necessary to use explicit transactions to get timely render tree updates. */ CATransaction 是 Core Animation 中的事务类，在 iOS 中的图层中，图层的每个改变都是事务的一部分。 CATransaction可以对多个layer的属性同时进行修改，同时负责成批的把多个图层树的修改作为一个原子更新到渲染树。 CATransaction事务类分为隐式事务和显式事务，注意以下两组概念的区分： 隐式动画和隐式事务: 隐式动画通过隐式事务实现动画 显式动画和显式事务: 显式动画有多种实现方式，显式事务是一种实现显式动画的方式。 UIView可以设置动画的属性： - frame & bounds & center - transform、scale、rotate - alpha - backgroundColor //基本 UIView.animateWithDuration(0.5, animations: { self.yourView.bounds.size.witdh += 70.0 self.yourView.backgroundColor = UIColor.greenColor() self.yourView.alpha = 0.5 }) //View和View之间的过渡 UIView.transitionWithView(containerView, duration: 0.2, options: .TransitionFlipFromLeft, animations: { _ in fromView.removeFromSuperview(); containerView.addSubview(toView) }, completion: nil) //入门Option,delay,option自由选择 UIView.animateWithDuration(0.5, delay: 0.4, options: .Repeat, animations:{ self.yourView.center.x + = 30.0 },completion: nil) //进阶，Spring属性可以调整动画的弹簧效果 UIView.animateWithDuration(1.5, delay: 0.0, usingSpringWithDamping: 0.2, initialSpringVelocity: 0.0, options: nil, animations: { self.loginButton.bounds.size.width += 80.0 label的文字可以进行一些过渡效果 }, completion: nil) //高阶，复杂动画组合之KeyFrame UIView.animateKeyframesWithDuration(1.5, delay: 0.0, options: nil, animations: { //添加KeyFrames，options中可以选择不同的限制 //1 UIView.addKeyframeWithRelativeStartTime(0.0, relativeDuration: 0.25, animations: { self.planeImage.center.x += 80.0 self.planeImage.center.y -= 10.0 }) //2 UIView.addKeyframeWithRelativeStartTime(0.1, relativeDuration: 0.4) { self.planeImage.transform = CGAffineTransformMakeRotation(CGFloat(- M_PI_4/2)) } }, completion: nil) CALayer layer 内部维护着三分 layer tree model Layer Tree(模型树) presentation Layer Tree Render Layer Tree (渲染树) 动画效果 size & position改变layer的位置及自身大小 transform改2D,3D情况下的现实效果 shadow改变阴影 border边框效果 opacity改其透明度 //记得引入QuartzCore //基本 let ownStyle = CABasicAnimation(keyPath:\"position.x\") ownStyle.fromValue = -view.bounds.size.width/2 ownStyle.toValue = view,bounds.size.width/2 ownStyle.duration = 0.5 yourView.layer.addAnimation(ownStyle, forKey: nil) //入门，动画之间存在时间差，我们可以设置fillMode和beginTime来实现特定效果 ownStyle.beginTime = CACurrentMediaTime() + 0.3 ownStyle.fillMode = KCAFillModeRemoved //default //kCAFillMode主要作用就是控制你动画在开始和结束时候的一些效果 //进阶 CAAnimation delegate pattern func animationDidStop & animationDidStart //与block中的相类似，你也可以利用KVC特性设置相应内容 ownStyle.setValue(yourView.layer, forKey:\"layer\") ownStyle.setValue(\"name\", forKey:\"form\") override func animationStop(anima: CAAnimation!, finished flag: Bool) { if let name = ownStyle.valueForKey(\"form\") as? String { if name = \"form\" { //add new animation and add it to the layer } } } //addAnimation中的Key作用，标示动画，在恰当的时候移除对应动画，而不是移除动画效果本身 //高阶，AnimationGroup let groupAnimation = CAAnimationGroup() let oneAnimation = CABasicAnimation(keyPath:\"transform.scale\") //blablabla let twoAnimation = CABasicAnimation(keyPath:\"opacity\") //detail set for twoAnimation //sey timingFunction groupAnimation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn) //这么只能一起做动画，这里内部没有时间顺序 groupAnimation.animations = [oneAnimation, twoAnimation] yourView.layer.addAnimation(groupAnimation, forKey: nil) //CAKeyFrame,关键帧动画Layer级别效果 let wobble = CAKeyframeAnimation(keyPath: \"transform.rotation\") wobble.duration = 0.25 wobble.repeatCount = 4 //比View的keyFrame设置方便多了 //values与keyTimes一一对应 wobble.values = [0.0, -M_PI_4/4, 0.0, M_PI_4/4, 0.0] wobble.keyTimes = [0.0, 0.25, 0.5, 0.75, 1.0] heading.layer.addAnimation(wobble, forKey: nil) //不过坑爹的是这样，比如CGPoint，CGSize，CGRect，CATransform3D，都要解包 let move = CABasicAnimation(keyPath: \"position\") move.duration = 1.0 move.fromValue = NSValue(CGPoint:CGPoint(x:100.0, y:100.0)) move.toValue = NSValue(CGPoint:CGPoint(x:200.0, y:200.0)) position bounds 参考 http://studentdeng.github.io/blog/2014/06/24/core-animation/ https://www.calayer.com/core-animation/2016/05/17/catransaction-in-depth.html#flushing-transactions https://lision.me/ios_rendering_process/ https://blog.ibireme.com/2015/05/18/runloop/ "},"ui/CoreGraphics.html":{"url":"ui/CoreGraphics.html","title":"CoreGraphics","keywords":"","body":"Core Graphics Overview Harness the power of Quartz technology to perform lightweight 2D rendering with high-fidelity output. Handle path-based drawing, antialiased rendering, gradients, images, color management, PDF documents, and more. 充分利用 Quartz 绘图引擎的能力来执行轻量级的 2D渲染操作，并且保证有高保真的输出。 具体包括 path绘制、抗锯齿渲染、渐变绘制、image绘制、颜色管理、PDF渲染等 Context Context 相当于Android里面的Canvas，使用UIGraphicsGetCurrentContext()获取当前CGContext的引用CGContextRef。我们在每一次的绘制之前都应该保存下原来的状态，待绘制完成后再恢复回原来的状态。所以CGContextSaveGState(ctx);… CGContextRestoreGState(ctx);都应该成对的出现，在他们之间的是绘制UI的代码。 绘制生成一个Image /* UIGraphicsRendererContext NSStringDrawingContext UIGraphicsImageRendererContext */ - (UIImage *)snapshot { UIGraphicsBeginImageContext(CGSizeMake(300, 300)); [self.grahpicsView drawViewHierarchyInRect:self.view.bounds afterScreenUpdates:YES]; // [self.grahpicsView.layer renderInContext:UIGraphicsGetCurrentContext()]; UIImage *img = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); /// 0-1的压缩 0为最大有损压缩 1为最高质量压缩 NSData *dataJPEG = UIImageJPEGRepresentation(img, 0.5); // png 格式的图片数据 NSData *dataPNG = UIImagePNGRepresentation(img); return img; } /* UIGraphicsRenderer UIGraphicsImageRenderer UIGraphicsPDFRenderer */ - (void)drawUIRender { // 这里可以设置渲染的图片格式 UIGraphicsImageRenderer *imgRender = [[UIGraphicsImageRenderer alloc] initWithSize:CGSizeMake(200, 200)]; UIImage *image = [imgRender imageWithActions:^(UIGraphicsImageRendererContext * _Nonnull context) { [[UIColor darkGrayColor] setStroke]; [context fillRect:CGRectMake(0, 0, 100, 100)]; }]; [self.imgView setImage:image]; } 绘图 - (void)drawRect:(CGRect)rect { // 在 drawRect 中，已经有CGContextRef了，不需要创建 // CGContextRef context = UIGraphicsGetCurrentContext(); // fill [[UIColor redColor] setFill]; UIRectFill(CGRectMake(50, 100, 100, 100)); // UIRectFillUsingBlendMode(CGRectMake(100, 100, 100, 100), kCGBlendModeNormal); // stroke [[UIColor purpleColor] setStroke]; UIRectFrame(CGRectMake(200, 100, 100, 100)); // Bezier Path [[UIColor blackColor] setStroke]; // UIBezierPath *path1 =[UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 250, 100, 100) cornerRadius:5]; UIBezierPath *path1 =[UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 250, 100, 100) byRoundingCorners:UIRectCornerTopLeft | UIRectCornerTopRight cornerRadii:CGSizeMake(20, 20)]; // 圆角的size path1.lineWidth = 5; [path1 stroke]; [[UIColor blackColor] setFill]; UIBezierPath *path2 =[UIBezierPath bezierPathWithOvalInRect:CGRectMake(200, 250, 100, 100)]; [path2 fill]; [[UIColor orangeColor] setStroke]; UIBezierPath *path3 =[UIBezierPath bezierPath]; [path3 moveToPoint:CGPointMake(50, 400)]; [path3 addLineToPoint:CGPointMake(50, 500)]; [path3 addLineToPoint:CGPointMake(100, 500)]; [path3 closePath]; // 闭合图形 [path3 setLineWidth:4]; [path3 setLineCapStyle:kCGLineCapRound]; [path3 setLineJoinStyle:kCGLineJoinBevel]; [path3 stroke]; self.bezierPath = path3; [[UIColor orangeColor] setStroke]; UIBezierPath *path4 =[UIBezierPath bezierPath]; [path4 addArcWithCenter:CGPointMake(120, 400) radius:30 startAngle:0 endAngle:M_PI clockwise:NO]; [path4 setLineWidth:4]; [path4 stroke]; // 随手指动 [[UIColor redColor] setStroke]; [[UIColor blackColor] setFill]; UIBezierPath *path5 =[UIBezierPath bezierPath]; [path5 addArcWithCenter:self.point radius:10 startAngle:0 endAngle:2 * M_PI clockwise:NO]; [path5 fill]; [path5 stroke]; // NSString NSDictionary *attrs = @{ NSForegroundColorAttributeName:[UIColor redColor] }; [@\"123你好\" drawInRect:CGRectMake(200, 400, 200, 200) withAttributes:attrs]; // image UIImage *image = [UIImage imageNamed:@\"widget_btn_card_normal\"]; [image drawInRect:CGRectMake(150, 450, 50, 50)]; } - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { // } // 滑动手势 - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event { UITouch *touch = touches.anyObject; CGPoint location = [touch locationInView:self]; self.point = location; [self setNeedsDisplay]; } // 点击是否在BezierPath内 - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event { UITouch *touch = touches.anyObject; CGPoint location = [touch locationInView:self]; if ([self.bezierPath containsPoint:location]) { NSLog(@\"点击到了 三角形\"); } } - (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event { // } 绘图效果： 其他 CGContext类，相当于Android里面的Canvas，使用UIGraphicsGetCurrentContext()获取当前CGContext的引用CGContextRef。我们在每一次的绘制之前都应该保存下原来的状态，待绘制完成后再恢复回原来的状态。所以CGContextSaveGState(ctx);… CGContextRestoreGState(ctx);都应该成对的出现，在他们之间的是绘制UI的代码。 CGPath类用于描述绘制的区域或者路线。在CGContext中addLine，addRect，其实都是在添加path,在添加完成path以后我们可以选择是fill path，还是stroke path。设置相应的 color 和 lineWidth 即可。如果我们只需要在某个区域中绘制，我们可以在描述完path以后使用CGContextClip(ctx)来裁剪当前画布。 CGAffineTransform是一个仿射变换的结构体，相当于一个矩阵，用于进行二维平面的几何变换（平移，旋转，缩放），而且这些几何变换都已经有封装好的函数可调用，变换的顺序就是矩阵连乘的顺序，切不可把矩阵连乘的顺序放反，否则得到的结果可能不一样。 CGColorSpace类是用于界面颜色显示，通常颜色组成为RGBA（红，绿，蓝，透明度）四种，使用CGColorSpaceCreateDeviceRGB获取CGColorSpace的引用CGColorSpaceRef,需要注意的是，在CoreGraphics中，使用create方法生成的引用，最后都需要调用release方法释放掉，如CGColorSpaceCreateDeviceRGB()对应的就是CGColorSpaceRelease(rgb)。 CGLayer 是一个专门用于离屏渲染的context，渲染结果可以重复利用。绘制过程中，可重复利用的渲染效果可以在在 CGLayer 实例中绘制，之后重复利用。 "},"ios/optimize/":{"url":"ios/optimize/","title":"App优化","keywords":"","body":"https://github.com/aozhimin/iOS-Monitor-Platform https://wereadteam.github.io/2016/05/03/WeRead-Performance/ "},"ios/optimize/crash.html":{"url":"ios/optimize/crash.html","title":"Crash优化","keywords":"","body":"crash 优化 想要追查到更深入的crash 需要学习 汇编层面的知识 https://juejin.im/post/5b35dcaee51d4558ca67465b "},"ios/optimize/kadun.html":{"url":"ios/optimize/kadun.html","title":"卡顿优化","keywords":"","body":"卡顿优化 参考 "},"ios/optimize/memory.html":{"url":"ios/optimize/memory.html","title":"内存优化","keywords":"","body":"内存优化 降低内存峰值 UIGraphicsBeginImageContext和UIGraphicsEndImageContext必须成双出现，不然会造成context泄漏。 WebView 替换 适当的添加 autoreleasetool能够及时释放内存，降低峰值 相互引用 self 被 block 持有 NSTimer 释放 线上内存监控： https://juejin.im/post/5aa79eeaf265da2392360487 "},"ios/optimize/appsize.html":{"url":"ios/optimize/appsize.html","title":"减小ipa包体积","keywords":"","body":"减小ipa包体积 清理 Extension 中的代码和资源 Extension 对应功能很少，但很容易 通过 Pod 引入大量的库 和 资源。 对应的解决方式： 使用动态库，在 ipa中，framework 只保留一份 引用少量的代码，可以考虑单独把用到的类拆分出来使用 清理资源 清理代码 "},"mvvm/":{"url":"mvvm/","title":"mvvm","keywords":"","body":"index override 重写(覆盖)。子类中重新实现父类的方法 overload 重载。一个类内，有多个方法，名称相同，参数不同。 多态。继承是子类使用父类的方法，而多态则是父类使用子类的方法。 "},"mvvm/rx-mvvm.html":{"url":"mvvm/rx-mvvm.html","title":"rx-mvvm","keywords":"","body":"rx-mvvm 主要目的：对于日常业务开发，如何组织代码结构。 优点： vc代码更少，代码拆分更清晰，更容易维护 更方便测试 更方便复用 view 具体模块包括：controller、View、Model、逻辑代码 要面对的问题： View在哪里创建，view展示的数据从哪里来，view对event的处理如何暴露出去 model数据更新时如何通知到view 具体的业务逻辑，应该写在哪里 VC作用 1.初始化view，viewModel private var nameField: UITextField! private var loginButton: UIButton! private func setup() { nameField = { let textField = UITextField() textField.borderStyle = .roundedRect view.addSubview(textField) textField.snp.makeConstraints { $0.top.equalToSuperview().offset(200) $0.width.equalTo(200) $0.height.equalTo(40) $0.centerX.equalToSuperview() } return textField }() loginButton = { let button = UIButton() button.setTitleColor(UIColor.gray, for: .normal) view.addSubview(button) button.snp.makeConstraints { $0.top.equalTo(passwordField.snp.bottom).offset(20) $0.width.equalTo(200) $0.height.equalTo(40) $0.centerX.equalToSuperview() } return button }() } 2. view 与 viewModel 相互绑定 private func bind() { // ==== 事件绑定 view -> viewModel loginButton.rx.tap .flatMapLatest({ [weak self] _ -> Observable in guard let `self` = self else { return Observable.error(RxLoginVCError.fail) } return Observable.just((username: self.nameField.text, password: self.passwordField.text)) }) .bind(to: viewModel.loginButtonTapObserver) .disposed(by: bag) // ==== viewModel -> view // navigation title viewModel.navigationBarTitleDriver .drive(rx.title) .disposed(by: bag) // 封装 alert 的逻辑 showAlertObserver = AnyObserver(eventHandler: { [weak self] (event) in guard let `self` = self, let element = event.element else { return } self.showAlert(element) }) viewModel.showAlertDriver .drive(showAlertObserver) .disposed(by: bag) } viewModel 作用 封装了 部分业务逻辑 class RxLoginVM: NSObject { // MARK: Output var navigationBarTitleDriver: Driver! // MARK: Input var loginButtonTapObserver: AnyObserver { return loginButtonTapSubject.asObserver() } private func bind() { // ViewModel -> View navigationBarTitleDriver = Driver .just(\"Login Page\") // Model ViewModel View loginButtonTapSubject.asObserver() // 用户点击登录按钮 VM Observable in guard let `self` = self else { return Observable.just(nil) } guard let username = tuple.username, !username.isEmpty else { self.showAlertSubject.onNext(\"empty username\") // 提示：用户没输入用户名 VM -> View return Observable.just(nil) } guard let password = tuple.password, !password.isEmpty else { self.showAlertSubject.onNext(\"empty password\") // 提示：用户没输入密码 VM -> View return Observable.just(nil) } self.setLoginButtonHiddeSubject.onNext(true) // 正常登录前隐藏登录按钮 VM -> View return self.model.login(username: tuple.username, password: tuple.password) // 正常登录调用 Model VM }) .do(onNext: { [weak self] _ in self?.setLoginButtonHiddeSubject.onNext(false) // 无论结果如何显示登录按钮 VM -> View }) .filter({ $0 != nil // 把异常情况过滤，因为已经提示过 }) .map { ($0 ?? false) ? \"Login Succeed\" : \"Login Failed\" } // 把登录结果的bool值转换为适当文本 .bind(to: showAlertSubject) // 把文本绑定到UI的提示控件上展示 VM -> View .disposed(by: bag) } } 使用RxSwift库，解决绑定问题 demo地址 https://github.com/quding0308/RxLogin-MVVM-Example 参考 https://objccn.io/issue-13-1/ "},"mvvm/rxswift.html":{"url":"mvvm/rxswift.html","title":"RxSwift","keywords":"","body":"RxWwift An API for asynchronous programming with observable streams 使用Observable流 实现了 异步编程的api。开发过程中，主要使用了 Observer模式，使用函数式编程。 几个核心概念： Observable Observer Subject (既是Observeable 又是 Observer) Disposable Scheduler 详细参考： http://blog.quding0308.com/blog/rxswift/2018/09/17/rxswift-basic.html 核心的操作 Operation ： 创建Observable 组合创建Observable 转换Observable 从Observable中发出指定元素 错误处理 详细参考： http://blog.quding0308.com/blog/rxswift/2018/09/18/rxswift-operation.html 冷、热 Obsrvable Hot and Cold Observable 官方介绍 When does an Observable begin emitting its sequence of items? It depends on the Observable. A “hot” Observable may begin emitting items as soon as it is created, and so any observer who later subscribes to that Observable may start observing the sequence somewhere in the middle. A “cold” Observable, on the other hand, waits until an observer subscribes to it before it begins to emit items, and so such an observer is guaranteed to see the whole sequence from the beginning. Variable、ControlProperty、ControlEvent、Driver等都是 Hot Observable 。不管有没有订阅者，都会发出 element 。Observable 中一般会有多个 element 。会共享状态变化。 Async Operation、Http Connection等是 Cold Observable 。有了订阅者后才会发出 element 。Observable 一般只有一个 element。不会共享状态变化。 参考 https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/why_rxswift.html RxJS https://rxjs-cn.github.io/learn-rxjs-operators/operators/multicasting/share.html "},"mvvm/rxcocoa.html":{"url":"mvvm/rxcocoa.html","title":"RxCocoa","keywords":"","body":"RxCocoa Binder Observer ，具有以下特征： 不处理error 默认 在主线程执行 Binder 主要用来给 View 增加 Observer，方便 在主线程中更新ui，并且不处理error，例如： extension Reactive where Base: UITabBarItem { public var badgeValue: Binder { return Binder(self.base) { tabBarItem, badgeValue in tabBarItem.badgeValue = badgeValue } } } Driver Observable sequence，具有以下特征： 不会失败(如果失败，会返回有默认值) 在主线程处理 observer 共享状态变化，有 shareReplay(1) 的行为 Driver 主要最适合用来更新 View let observable = Observable.just(1) let driver = observable.asDriver(onErrorJustReturn: 0) //asDriver() 等价于 let driver = observable .observeOn(MainScheduler.instance) // 主线程监听 .catchErrorJustReturn(onErrorJustReturn) // 无法产生错误 .share(replay: 1, scope: .whileConnected)// 共享状态变化 ControlProperty 既是Observable，又是 Observer，用于封装UI控件的属性，具有一下特点： 不产生error 订阅 和 监听 都在 主线程 共享状态变化，有 shareReplay(1) 的行为 有初始值 使用： extension Reactive where Base: UITextField { public var text: ControlProperty { return base.rx.controlPropertyWithDefaultEvents( getter: { textField in textField.text }, setter: { textField, value in // This check is important because setting text value always clears control state // including marked text selection which is imporant for proper input // when IME input method is used. if textField.text != value { textField.text = value } } ) } } // as observable textField.rx.text.bind(to: label.rx.text) // as observer let observable = Observable.from([\"1\"]) observable.bind(to: textField.rx.text) ControlEvent Observable，用于封装 UI控件的事件，具有以下特点： 不产生error 订阅 和 监听 都在 主线程 共享状态变化 没有初始值 使用： extension Reactive where Base: UIButton { /// Reactive wrapper for `TouchUpInside` control event. public var tap: ControlEvent { return controlEvent(.touchUpInside) } } // as observable btn.rx.tap.subscribe(onNext: { print(\"tapped\") }).disposed(by: disposebag) Signal Bag 用于回收 "},"ios/bug/":{"url":"ios/bug/","title":"常见bug","keywords":"","body":"bug "},"web/":{"url":"web/","title":"web","keywords":"","body":"web 网络优化 渲染 "},"web/url.html":{"url":"web/url.html","title":"URL","keywords":"","body":"URL search / query 在 url 中，search 在前，hash 在后。 query的规定是以第一个 ? 开始，至行尾或 # 结束 fragment以 # 为开始，行尾为结束 hash(#) fragment '#' 代表网页的一个位置。# 右面的字符就是该位置的标识符。 '#' 用来指导浏览器的动作，对服务器完全无用。http 请求中，会忽略掉 # 之后的字符。 改变 # 后的字符，浏览器只会滚动到相应位置，不会重新加载页面。 改变 # 后的字符，会改变浏览器的访问历史。每次改动，都会在访问历史中增加一个记录。 通过 window.location.hash 可以读写 hash 值。写入时，会滚动到指定页面（不会重载页面，但会创造一条访问历史记录） window.location.hash = '' hash 值改变后，会触发 onhashchange 事件。 window.onhashchange = function () { // } vue 中 hash 与 history 模式： https://router.vuejs.org/zh/guide/essentials/history-mode.html 参考 https://tools.ietf.org/html/rfc3986 "},"web/html.html":{"url":"web/html.html","title":"HTML","keywords":"","body":"概要 HyperText Markup Language 标记语言 描述内容的含义和结构 CSS 网页的展示 JavaScript 功能与行为 使用 “元素” 来定义文档结构。 HTML Header title123 --> HTML TAG // 文档的元数据 // 导航栏（含有多个链接，可跳转到其他页面） // 内联tag，没有特殊含义 // 表示一个和其余页面内容不相关的部分 // 外部内容嵌入到文档中 tag参考： https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element JS操作 dom 与 CSS Ajax Asynchronous JavaScript + XML（异步JavaScript和XML） Window 属性 window.location window.history window.document window.frames window.localStorage window.indexDB window.alert() window.confirm() window.prompt() window.console() // cookie 属于 Document window.document.cookie Location 表示当前 web 页面的 URL 信息 location.reload() // 重新刷新当前页面 location.assign() // 加载指定页面（history 中有记录） location.replace() // 加载指定页面（history 中没有记录） loation.href location.protocol // http: location.host location.port location.pathname location.search location.hash location.origin Document Cookie cookie 是 Document 的属性 window.document.cookie "},"web/css.html":{"url":"web/css.html","title":"CSS","keywords":"","body":"CSS Cascading Style Sheet 样式描述语言 cascade 瀑布；级联； 从内容中分离样式，有助于复用，更容易维护，同样的内容可以使用不同的样式。 概要 一条CSS规则： selector { // 花括号中的部分为声明 property：value; property: value; } 层叠 和 继承 层叠 浏览器对HTML元素定义的默认样式 开发者定义的样式 外联样式 style.css 内联样式 在页面的头部定义，只在本页面生效 行内样式 定义在特定元素上 继承 继承 选择器 Selectors tag selector(type selector) body{ background-color: lightgray; } p{ color: blue; text-decoration: underline; } class selector 通过设置元素的 class 属性，可以为元素指定类名。类名由开发者自己指定。 文档中的多个元素可以拥有同一个类名。 .title { // 以 . 开头声明 color: yellow; } // html class selector 比 tag selector 优先级更高 p2 id selector 通过设置元素的 id 属性为该元素制定ID。ID名由开发者指定。每个ID在文档中必须是唯一的。 #myname { // 以 # 开头声明 color: purple; } // html p3 // id 比 class 优先级更高 p3 Pseudo-classes selector CSS伪类（pseudo-class）是加在选择器后面的用来指定元素状态的关键字。比如，:hover 会在鼠标悬停在选中元素上时应用相应的样式。 .title:hover { color: yellow; } a { color: red; } a:visited { color: orange; } 伪类列表： :link // link 没有访问过 :visited // link 已访问过 :active // 被激活的时候 :hover // 鼠标停留 :focus // link 被选中的时候 :first-child // 第一个元素 :nth-child // 子元素中，按照位置先后顺序排序，第 n 个元素 :nth-last-child :nth-of-type :first-of-type :last-of-type :empty :target :checked :enabled :disabled 参考：https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-child 基于关系的选择器 // 后代选择器 A E 元素A的任一后代元素E // 子选择器 A > E 元素A的任一子元素E(E必须紧挨着A) // 相邻兄弟选择器 B + E 元素B的任一下一个兄弟元素E(第一个兄弟元素如果是E，则起作用) B + * 元素B的下一个兄弟元素 // 通用兄弟选择器 B ~ E 元素B之后的所有类型为E的兄弟元素 B ~ * 表示 元素B之后的所有兄弟元素 demo： // id 为data-table-1，table 中每行的第一个元素 为 bolder；第二个元素使用等宽字体。 #data-table-1 td:first-child {font-weight: bolder;} #data-table-1 td:first-child + td {font-family: monospace;} a.homepage:hover, a.homepage:focus, a.homepage:active { background-color: #666; } // 使用CSS 创建下了菜单 div.menu-bar ul ul { display: none; } div.menu-bar ul:hover ul { display: block; } 属性选择器 通过已经存在的属性名或属性值来匹配元素 // 存在 title 属性的 a 元素 a[title] { font-size: 2rem; } // 有 href 属性，并且值为 http://www.baidu.com 的 a 元素 a[href=\"http://www.baidu.com\"] { font-style: bold; } // href 属性的值以 https:// 开头的 a 元素 a[href^=\"https://\"] { font-style: bold; } // href 属性的值以 .com 结尾的 a 元素 a[href$=\".com\"] { font-style: bold; } // href 属性的值包含 baidu 字符的 a 元素 a[href*=\"baidu\"] { font-style: bold; } [attr~=value] 表示带有以 attr 命名的属性的元素，并且该属性是一个以空格作为分隔的值列表，其中[至少]一个值匹配\"value\"。 [attr|=value] 表示带有以 attr 命名的属性的元素，属性值为“value”或是以“value-”为前缀（\"-\"为连字符，Unicode编码为U+002D）开头。典型的应用场景是用来来匹配语言简写代码（如zh-CN，zh-TW可以用zh作为value）。 框属性 margin padding border 文字样式 .class-font { color: red; font-family: -apple-system; /* 1em 等于 当前元素的父元素上设置的字体大小 */ font-size: 2.5em; /* font-style: normal; */ font-style: italic; /* font-weight: normal; */ font-weight: bold; /* text-decoration: none; */ /* text-decoration: underline; */ /* text-decoration: overline; */ text-decoration: line-through; /* text-transform: none; */ /* text-transform: uppercase; */ /* text-transform: lowercase; */ text-transform: capitalize; /* 水平偏移 垂直偏移 模糊半径 阴影颜色 */ text-shadow: 4px 4px 5px red; /* 文本布局 */ /* 对齐方式 */ /* text-align: left; */ /* text-align: right; */ /* text-align: center; */ text-align: justify; /* 行高 2.5为乘数 */ line-height: 2.5; /* 字间距 */ letter-spacing: 10px; /* 单词间距 */ word-spacing: 50px; } 动画 Animation 参考：https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Animations/Using_CSS_animations 动画 从一个CSS样式转换到另一个CSS样式。 一个动画包括： 动画的样式规则 动画开始、结束、中间时刻的帧 p { animation-name: slidein; animation-duration: 3s; animation-delay: 5s; animation-iteration-count: infinite; animation-direction: alternate; } @keyframes slidein { from { margin-left: 100%; width: 300%; } 75% { font-size: 300%; margin-left: 25%; width: 150%; } to { margin-left: 0%; width: 100%; } } 媒体查询 @Media 媒体查询，允许内容的呈现针对一个特定范围的输出设备而进行裁剪，而不必改变内容本身。 官方文档：https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries @media (max-width: 600px) { .side_bar { display: none; } } CSS Grid and Flexbox layout 参考： https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Relationship_of_Grid_Layout 网格布局和弹性布局的区别： Flexbox 是一维布局（沿横向或纵向） Grid 是二维布局（同时沿横向和纵向） Flexbox https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout flex-flow、flex-direction、flex-wrap(container属性，对子元素生效) 指定了内部子元素布局的主轴方向 /* The direction text is laid out in a line */ flex-direction: row; /* Like , but reversed */ flex-direction: row-reverse; /* The direction in which lines of text are stacked */ flex-direction: column; /* Like , but reversed */ flex-direction: column-reverse; flex-wrap 指定了内部元素如果一行无法显示时，是否允许换行 取值： flex-wrap: nowrap // default value flex-wrap: wrap flex-wrap: wrap-reverse flex-flow flex-flow 是 flex-direction 和 flex-wrap 的简写。 flex-flow: row nowrap； // default value flex-flow: wrap； flex-flow: column wrap-reverse; justify-content (container属性，对子元素生效) 定义了在主轴方向，如何分配元素直接的空间。 只适用于 多行 flex容器。 使用前提：所有弹性元素的 flex-glow 等于0，才生效。（如果存在至少一个弹性元素，则会自动占满空间） 注意：如果没有主动设置 flex，此时 flex 默认为：flex: inherit inherit auto，则 justify-content 生效 /* Distributed alignment */ justify-content: space-between; /* 均匀排列每个元素 首个元素放置于起点，末尾元素放置于终点 */ justify-content: space-around; /* 均匀排列每个元素 每个元素周围分配相同的空间 */ justify-content: space-evenly; /* 均匀排列每个元素 每个元素之间的间隔相等 */ /* Baseline alignment */ justify-content: baseline; justify-content: first baseline; justify-content: last baseline; /* Positional alignment */ justify-content: center; /* 居中排列 */ justify-content: start; /* Pack items from the start */ justify-content: end; /* Pack items from the end */ justify-content: flex-start; /* 从行首起始位置开始排列 */ justify-content: flex-end; /* 从行尾位置开始排列 */ justify-content: left; /* Pack items from the left */ justify-content: right; /* Pack items from the right */ align-content (container属性，对子元素生效) 定义了横轴方向(cross axis)，如何分配内容和空间。 该属性对单行flexbox无效，也就是当设置 flex-wrap: nowrap 时，align-content 无效。 /* 默认对齐 stretch */ align-content: normal; align-content: stretch; /* 分布式对齐 */ align-content: space-between; /* 均匀分布项目 第一项与起始点齐平， 最后一项与终止点齐平 */ align-content: space-around; /* 均匀分布项目 项目在两端有一半大小的空间*/ align-content: space-evenly; /* 均匀分布项目 项目周围有相等的空间 */ align-items (container属性，对子元素生效) align-items 用于设置 flex item 纵轴方向的对齐方式。 align-items 关注纵轴方向单行元素内的对齐，align-content 关注纵轴方向多行元素的对齐。 如果设置 flex-wrap: nowrap; ，则 align-content 无效，align-items 仍有效。 对所有直接子节点的 align-self 统一设置。 The align-items property applies to all flex containers, and sets the default alignment of the flex items along the cross axis of each flex line. align-items has the same functionality as align-content but the difference is that it works to center every single-line container instead of centering the whole container. The align-content property only applies to multi-line flex containers, and aligns the flex lines within the flex container when there is extra space in the cross-axis. // 默认值 stretch 拉伸 align-items: normal; align-items: stretch; align-items: center; // 元素在侧轴居中 align-items: flex-start; // 元素向侧轴起点对齐 align-items: flex-end; // 元素向侧轴终点对齐 align-items: baseline; align-self 对 flex item 设置，会覆盖 container 中 align-items 的值。 // default value flex-self: auto align-content 与 align-items 的区别： https://blog.csdn.net/sinat_27088253/article/details/51532992 https://stackoverflow.com/questions/31250174/css-flexbox-difference-between-align-items-and-align-content flex、flex-grow、flex-shrink、flex-basis flex flex: 1 1 20px; 三个参数对应： flex-grow 拉伸因子(按百分比计算 default 0) flex-shrink 收缩因子（按百分比计算 default 1） flex-basis 指定了flex元素在主轴方向的初始大小(default auto) flex: auto 等价于 flex: 1 1 auto 根据自身宽高设置尺寸，会伸长或缩短自身以适应容器 flex: initial 等价于 flex: 0 1 auto 默认值。根据自身宽高设置尺寸，会缩短自身以适应容器，但不会伸长 flex: none 等价于 flex: 0 0 auto 根据自身宽高设置尺寸，不会伸长或缩短来适应容器，完全是非弹性的。 flex 属性可以指定1个，2个或3个值。 flex: 2 设置了 flex-grow 等价于 flex: 2 1 auto flex: 30px 设置了 flex-basis 等价于 flex: 1 1 30px flex: 2 30px 等价于 flex: 2 1 30px flex: 2 2 等价于 flex: 2 2 auto order 规定了 弹性容器中的可伸缩项目在布局时的顺序。具有相同order的元素按代码顺序布局 default value 0 参考 https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference "},"web/layout.html":{"url":"web/layout.html","title":"布局相关","keywords":"","body":"layout 常见布局思路 宽度自适应，高度写死 使用 flex 布局，宽度使用百分比布局。高度写死 固定px。 缺点：不同屏幕，会拉伸 UI 固定宽度 宽度写死，在大屏幕上会左右留空白 使用 viewport 进行缩放 以 320 宽度为基准，进行缩放，最大缩放为 320*1.3 = 416，基本缩放到416都就可以兼容iphone6 plus的屏幕了 使用 rem 能够等比例适配所有屏幕 指定根元素 html font-size，其他元素使用 rem 为单位布局。 html { font-size: 20px; } rem 与 em 的区别： em 相对于当前对象内文本的字体尺寸 rem 相对于根元素 html 的文本的字体尺寸 参考： http://caibaojian.com/web-app-rem.html https://juejin.im/post/5b41bf63f265da0f8b2f9656 https://www.runoob.com/w3cnote/px-em-rem-different.html viewport 手机浏览器是把页面放在一个虚拟的\"视口\"（viewport）中，通常这个虚拟的 viewport 比屏幕宽，这样就不用把每个网页挤到很小的窗口中（这样会破坏没有针对手机浏览器优化的网页的布局），用户可以通过平移和缩放来看网页的不同部分。 在浏览器窗口css的布局区域，布局视口的宽度限制css布局的宽。为了能在移动设备上正常显示那些为pc端浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或其他值，一般都比移动端浏览器可视区域大很多，所以就会出现浏览器出现横向滚动条的情况 我们可以设置 viewport 的属性，让页面根据手机的实际屏幕宽度来布局。 width：控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。 height：和 width 相对应，指定高度。 initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。 maximum-scale：允许用户缩放到的最大比例。 minimum-scale：允许用户缩放到的最小比例。 user-scalable：用户是否可以手动缩放。 宽度、高度 devicePixelRatio 获取屏幕 物理像素分辨率 与 CSS像素分辨率 的比值 在 iPhone 8， dpr = 2 在 iPhone 8 plus， dpr = 3 var dpr = window.devicePixelRatio; 在 iOS 中获取方式： let scale = UIScreen.main.scale document.body.clientWidth 与 document.body.clientHeight 获取展示内容的宽高 (375, 423)，类比 iOS 中 scrollView.contentSize 如果内容可以上下滚动，则获取的是 scrollView.contentSize.height let width = window.document.body.clientWidth let height = window.document.body.clientHeight window.innerWidth 与 window.innerWidth 可视区域的高度 在 safari 中会去掉 status bar、navigation bar、toobar 计算高度。 在 WKWebView 中需要根据 vc.edgesForExtendedLayout 来 确定是否计算 status bar、navigation bar 的高度 let width = window.innerWidth let height = window.innerHeight window.outerWidth 与 window.outerWidth 可视区域的高度，屏幕的真实宽高 let width = window.innerWidth let height = window.innerHeight scrollTop 与 scrollLeft 设置滚动 window.document.body.scrollTop = 300 "},"web/event.html":{"url":"web/event.html","title":"事件处理","keywords":"","body":"鼠标点击和触摸屏点击 捕获 capture 冒泡 bubble 捕获是计算机处理输入的逻辑，冒泡是人类理解事件的思维，捕获总是在冒泡之前发生。 事件处理，默认使用冒泡方式。冒泡方式，上层的 div 先触发回调 DOM Events 处理有3个阶段： Capture pahse the event goes down to the element Target Phase the event reached the target element Bubbling Phase the event bubbles up from the element Event 属性： event.target 最深处的 element event.currentTarget 处理 event 的当前 element event.eventPhase (capturing=1, target=2, bubbling=3) /* addEventListener(event, function, useCapture) event: click mousedown useCapture: 默认 false true 事件在捕获阶段执行； false 事件在冒泡阶段执行 */ window.addEventListener('mousedown', () => { console.log('window1') }, true) document.addEventListener('mousedown', () => { console.log('document1') }, true) document.body.addEventListener('mousedown', () => { console.log('key1') }, true) document.getElementById('i').addEventListener('mousedown', () => { console.log('key2') }, true) window.addEventListener('mousedown', () => { console.log('window11') }, false) document.addEventListener('mousedown', () => { console.log('document11') }, false) document.body.addEventListener('mousedown', function (event) { console.log('key11') console.log(event.eventPhase) console.log(event.target) console.log(event.currentTarget) }, false) document.getElementById('i').addEventListener('mousedown', function () { console.log('key22') }, false) // 输出结果为 // 捕获：window1 document1 key1 key2 // 冒泡：key22 key11 document11 window11 停止 冒泡 event.stopPropagation() 特例 focus 事件不会冒泡 焦点 键盘事件时有焦点系统控制的。 在整个 UI 系统中，有且仅有一个“聚焦”的元素。只有一个 FirstResponder // 获取焦点 document.getElementById('i').focus() // 失去焦点 document.getElementById('i').blur() iOS 中处理 WKWebView 默认不制止 代码设置焦点，弹出键盘 需要修改下 WKWebView 内部实现 _wkWebView.keyboardDisplayRequiresUserAction = NO; import Foundation import WebKit typealias OldClosureType = @convention(c) (Any, Selector, UnsafeRawPointer, Bool, Bool, Any?) -> Void typealias NewClosureType = @convention(c) (Any, Selector, UnsafeRawPointer, Bool, Bool, Bool, Any?) -> Void /// 支持：设置自动获取焦点后，弹出键盘 extension WKWebView{ @objc var keyboardDisplayRequiresUserAction: Bool { get { return self.keyboardDisplayRequiresUserAction ?? true } set { self.setKeyboardRequiresUserInteraction(newValue ?? true) } } func setKeyboardRequiresUserInteraction( _ value: Bool) { guard let WKContentView: AnyClass = NSClassFromString(\"WKContentView\") else { print(\"keyboardDisplayRequiresUserAction extension: Cannot find the WKContentView class\") return } // For iOS 10, * let sel_10: Selector = sel_getUid(\"_startAssistingNode:userIsInteracting:blurPreviousNode:userObject:\") // For iOS 11.3, * let sel_11_3: Selector = sel_getUid(\"_startAssistingNode:userIsInteracting:blurPreviousNode:changingActivityState:userObject:\") // For iOS 12.2, * let sel_12_2: Selector = sel_getUid(\"_elementDidFocus:userIsInteracting:blurPreviousNode:changingActivityState:userObject:\") if let method = class_getInstanceMethod(WKContentView, sel_10) { let originalImp: IMP = method_getImplementation(method) let original: OldClosureType = unsafeBitCast(originalImp, to: OldClosureType.self) let block : @convention(block) (Any, UnsafeRawPointer, Bool, Bool, Any?) -> Void = { (me, arg0, arg1, arg2, arg3) in original(me, sel_10, arg0, !value, arg2, arg3) } let imp: IMP = imp_implementationWithBlock(block) method_setImplementation(method, imp) } if let method = class_getInstanceMethod(WKContentView, sel_11_3) { let originalImp: IMP = method_getImplementation(method) let original: NewClosureType = unsafeBitCast(originalImp, to: NewClosureType.self) let block : @convention(block) (Any, UnsafeRawPointer, Bool, Bool, Bool, Any?) -> Void = { (me, arg0, arg1, arg2, arg3, arg4) in original(me, sel_11_3, arg0, !value, arg2, arg3, arg4) } let imp: IMP = imp_implementationWithBlock(block) method_setImplementation(method, imp) } if let method = class_getInstanceMethod(WKContentView, sel_12_2) { let originalImp: IMP = method_getImplementation(method) let original: NewClosureType = unsafeBitCast(originalImp, to: NewClosureType.self) let block : @convention(block) (Any, UnsafeRawPointer, Bool, Bool, Bool, Any?) -> Void = { (me, arg0, arg1, arg2, arg3, arg4) in original(me, sel_12_2, arg0, !value, arg2, arg3, arg4) } let imp: IMP = imp_implementationWithBlock(block) method_setImplementation(method, imp) } } } "},"web/less.html":{"url":"web/less.html","title":"less介绍","keywords":"","body":"less 的使用 概述 less 中文文档： https://less.bootcss.com/features/ Less （Leaner Style Sheets 的缩写） 是一门向后兼容的 CSS 扩展语言，是 CSS 的超集。 在 CSS 的基础上，增加了一些新的特性，使 CSS 写起来更高效，更令人愉悦。 特性 通过 Variables、Maps、Mixins 可以抽离出通用的 rule-set ，方便复用。 通过 importing、Nesting、Namespace 可以让代码更模块化，结构更清晰，同时也可以避免全局污染。 通过 Function、Operation 可以让计算更灵活，属性间的依赖可以直接通过函数或 Operation 来计算。 变量 Variables @width: 10px; @height: @width + 10px; #header { width: @width; height: @height; } 混合 Mixins 类似继承或组合的概念，定义一个 rule-set ，然后在另一个 rule-set 中直接使用之前定义的的 rule-set .bordered { border-top: dotted 1px black; border-bottom: solid 2px black; } .btn1 { width: @width; height: @height; .bordered() } 嵌套 Nesting #content { background-color: lightgrey; button { background-color: lightgoldenrodyellow; } .btn1-wraper { button { color: red; } } .btn2-wraper { button { color: blueviolet; } } } 导入 importing // 可以 @import \"./less_study2\"; @import \"./less_study2.css\"; 作用域 使用就近的 Variable @var: red; #page { @var: white; #header { color: @var; // white } } Maps 定义类似 Map 的数据，在 less 代码中使用 #colors() { primary: red; secondry: green; } .button { } Escaping 可以理解为反斜杠相同作用，直接替换文本 /* 旧的写法 */ /* @min768: ~\"(min-width: 768px)\"; */ @min768: (min-width: 768px); .element { @media @min768 { font-size: 1.2rem; } } /* 会生成 CSS ： */ @media (min-width: 768px) { .element { font-size: 1.2rem; } } Namespace 类比 c++中的 namespace 命名空间，在这个 namespace 中定义的 Variable、Map等，不会被污染。使用时，namespace.selector 这种方式即可调用 #qd() { .bordered { border-top: dotted 1px black; border-bottom: solid 2px black; } } .btn1 { width: @width; height: @height; #qd.bordered() } 运算 Operations / 基本运算可以用于 数字、颜色、变量。 // example with variables @base: 5%; @filler: @base * 2; // result is 10% @other: @base + @filler; // result is 15% 函数 Function less 内置了很多函数，参考：https://less.bootcss.com/functions/ @width: 0.5; @width_percentage: percentage(@width); // returns `50%` // 颜色 color(\"#aaa\"); image-width(\"file.png\"); image-height(\"file.png\"); image-size(\"file.png\"); data-uri('../data/image.jpg'); // 会生成base64的 output url('data:image/jpeg;base64,bm90IGFjdHVhbGx5IGEganBlZyBmaWxlCg=='); // String escape('a=1') // url encode 编码 a%3D1 自定义函数 // px转rem .px2rem(@name, @px){ @{name}: @px / 50 * 1rem; } .btn { .px2rem(height, 100); } // 生成为： .btn { height: 2em; } "},"web/csp.html":{"url":"web/csp.html","title":"Content Security Policy","keywords":"","body":"Content Security Policy CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。使用 CSP 主要防止 XSS 攻击。 启用CSP 设置 Content-Security Content-Security-Policy: script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https: 设置 标签 具体配置 script-src 'self'; // js只信任当前域名 object-src 'none'; // 标签 不信任任何URL，即不加载任何资源 style-src cdn.example.org third-party.org; // css 只信任 cdn.example.org和third-party.org child-src https: // 其他资源：没有限制 示例： // 各配置的默认选项 self 所有外部资源只能从当前域名加载 Content-Security-Policy: default-src 'self' 参考 http://www.ruanyifeng.com/blog/2016/09/csp.html https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP 同源策略 same-origin policy 同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。 如果网站没有提供CSP头部，则浏览器使用标准的同源策略。 什么是同源 同源 指 域名、协议、端口都相同。 scheme + host + port 都相同才算是同源。 同一域名下的 http 和 https请求 属于不同源 同源策略的限制： Cookie、LocalStorage、IndexDB无法读取 DOM 无法获取 Ajax 请求不能发送 参考 http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy CORS Cross-Origin Resource Sharing 跨域资源共享 跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。 简单请求 浏览器发现ajax请求时跨源的请求，会自动在request header增加Origin字段 GET /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0 服务器根据Origin决定是否同意这次请求。如果Origin指定的域名在许可范围内，则服务器返回response，会在header 多增加几个字段 Access-Control-Allow-Origin: http://api.bob.com // 表示 server 接受的域名请求 Access-Control-Allow-Credentials: true // 告知浏览器是否可以携带cookie Access-Control-Expose-Headers: FooBar // Content-Type: text/html; charset=utf-8 参考 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS http://www.ruanyifeng.com/blog/2016/04/cors.html "},"web/render.html":{"url":"web/render.html","title":"页面渲染","keywords":"","body":"渲染 建议直接阅读原文 浏览器渲染步骤： 处理 HTML 标记并构建 DOM 树。 处理 CSS 标记并构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，以计算每个节点的几何信息。 将各个节点绘制到屏幕上。 1.构建 DOM 树 Critical Path Hello web performance students! 从网络或磁盘读取html文件，根据文件编码转换成字符 根据 html 标准，解析尖括号tag，尖括号内的字符串 词法分析。根据解析的 Tokens ，转换成定义其属性的和规则的对象 构建DOM树。把对象链接在一个树数据结构内，确定整个DOM树结构 2.构建 CSSOM 树 body { font-size: 16px } p { font-weight: bold } span { color: red } p span { display: none } img { float: right } 从网络或磁盘读取css文件，根据文件编码转成字符 根据语法规则，解析字符为 Token 根据解析的 Token，生成 Node，每个Node 有自己的属性 构建 CSSOM 树。 3.构建渲染树 DOM树 和 CSSOM树合并后形成渲染树。 渲染树只包含可见节点和他们的计算样式。 从DOM树根节点，遍历每个可见节点 对于每个可见节点，为其寻找CSSOM规则，并应用 请注意 visibility: hidden 与 display: none 是不一样的。前者隐藏元素，但元素仍占据着布局空间（即将其渲染成一个空框），而后者 (display: none) 将元素从渲染树中完全移除，元素既不可见，也不是布局的组成部分。 4.布局layout 根据渲染树 计算每个节点在设备内的确切位置和大小。 布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸：所有相对测量值都转换为屏幕上的绝对像素。 布局完成后我们知道了 哪些节点可见，他们的计算样式，和 节点在设备上的确切位置和大小。 5.绘制 paint 将渲染树中的每个节点转换成屏幕上的实际像素。这一步通常称为“绘制”或“栅格化”。 优化关键渲染路径 优化关键渲染路径是优先显示与当前用户操作相关的内容，缩短浏览器渲染的时间 阻塞渲染的CSS CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。 HTMl 和 CSS 都是阻塞渲染的资源。 默认情况下 CSS 是阻塞渲染的资源，可以通过设置 meida 了行，将一些 CSS 标记为不阻塞渲染 浏览器会下载所有的CSS资源，无论阻塞或不阻塞 // 只有在 打印 的时候使用的css，不会阻塞web端渲染 // 指定条件下使用的css，不满足条件的话不阻塞渲染 // 竖屏 才使用 防止 JavaScript 阻塞渲染 JavaScript 脚本在文档的何处插入，就在何处执行。 当 HTML 解析器遇到一个 script 标记时，它会暂停构建 DOM，将控制权移交给 JavaScript 引擎；等 JavaScript 引擎运行完毕，浏览器会从中断的地方恢复 DOM 构建。 Javascript 线程 和 UI 线程不会同时执行，是互斥的。 “优化关键渲染路径”在很大程度上是指了解和优化 HTML、CSS 和 JavaScript 之间的依赖关系谱。 JavaScript 可以查询和修改 DOM 与 CSSOM。 JavaScript 在 DOM 构建之前，操作 DOM 则找不到元素 JavaScript 在 CSSOM 构建之前操作 CSSOM，则浏览器将延迟脚本执行和 DOM 构建，直至其完成 CSSOM 的下载和构建。 当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。 优化： // 异步执行 script 使用 Navigation Timing API 测量性能 domLoading 开始解析HTML文档 domInteractive DOM构建完成 domContentLoaded DOM 与 CSSOM 构建完成，准备构建渲染树 domComplete 网页与子资源(包括图片)都就绪 loadEvent 网页加载最后一步，触发 onload 事件 Critical Path: Measure function measureCRP() { var t = window.performance.timing, interactive = t.domInteractive - t.domLoading, dcl = t.domContentLoadedEventStart - t.domLoading, complete = t.domComplete - t.domLoading; var stats = document.createElement('p'); stats.textContent = 'interactive: ' + interactive + 'ms, ' + 'dcl: ' + dcl + 'ms, complete: ' + complete + 'ms'; document.body.appendChild(stats); } Hello web performance students! 参考：https://developers.google.com/web/fundamentals/performance/critical-rendering-path/measure-crp?hl=zh-cn 渲染一个页面的demo Hello web performance students! 渲染流程： 这个关键渲染路径中，包括： 关键资源： 可能阻止网页首次渲染的资源。3个关键资源 关键路径长度： 获取所有关键资源所需的往返次数或总时间。至少2次请求时间 关键字节。11KB 优化关键渲染路径的步骤： 分析关键资源、字节数、路径长度 最大限度减少关键资源 压缩关键字节数，缩短下载时间(tcp往返次数) 优化关键资源加载顺序，尽早下载所有关键资源，以此缩短关键长度 参考 https://developers.google.com/web/fundamentals/performance/critical-rendering-path/?hl=zh-cn "},"web/web_optimize.html":{"url":"web/web_optimize.html","title":"页面加载优化","keywords":"","body":"页面加载优化 待填坑 "},"web/json.html":{"url":"web/json.html","title":"json的使用","keywords":"","body":"json的使用 json 转 js的object var json = '{\"name\": \"Peter\", \"sex\": \"male\"}'; var obj2 = eval('(' + json + ')'); var obj3 = JSON.parse(json); js的object 转 json var json = '{\"name\": \"Peter\", \"sex\": \"male\"}'; var str2 = JSON.stringify(obj); JSON 类型 JavaScript Object Notation null true/false Boolean 123 Number “Peter” String(使用双引号) {“key”:\"value”} Object [a,b,c] Array // JSON 语法 // JSON 中使用双引号 { \"name\": \"Peter\", \"age\": 21, \"aa\": null, \"bb\": true, \"cc\": false, \"dd\": { \"a\": \"b\" }, \"ee\": [ 1, { \"a\": 12, \"b\": 34 } ] } "},"web/js-extension.html":{"url":"web/js-extension.html","title":"JavaScript 基础知识","keywords":"","body":"JavaScript 在 JavaScript 中，对象的状态和行为都被抽象为属性。方法是 Function 类型的对象 JavaScript 中对象独有的特色是：对象具有高度的动态性，在运行时可以为对象添加状态和行为。 var o = { a: 1 }; o.b = 2; console.log(o.a, o.b); //1 2 JavaScript 对象的属性 数据属性 数据属性的特征： value 属性值 writable 属性是否被赋值 enumerable 决定 for in 是否可以枚举该属性 configurable 决定书写是否被删除或改变 var o = { a: 1 }; o.b = 2; //a 和 b 皆为数据属性 Object.getOwnPropertyDescriptor(o, \"a\") // {value: 1, writable: true, enumerable: true, configurable: true} Object.getOwnPropertyDescriptor(o, \"b\") // {value: 2, writable: true, enumerable: true, configurable: true} 访问器属性 访问器属性的特征： getter 取属性值是被调用 默认 undefined setter 设置属性值是被调用 默认 undefined enumerable 决定 for in 是否可以枚举该属性 configurable 决定书写是否被删除或改变 var o = { get a() { return 1 } }; console.log(o.a); // 1 参考 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html "},"web/js-object.html":{"url":"web/js-object.html","title":"JavaScript 对象","keywords":"","body":"JavaScript 中对象、继承 和 原型链 class 相关 class Point { name = 'Peter' // 新写法，定义实例属性 与 x、y 等价 static staticProp = '静态属性' constructor(x, y) { this.x = x; this.y = y; } toString() { return '(' + this.x + ', ' + this.y + ')'; } get prop() { return this.name } set prop(value) { this.name = value } // 静态方法 不可以被实例继承 static hellWorld() { // } } let p = new Point(2, 3) p.toString() p.hasOwnProperty('x') // this 是实例对象自己的属性 p.hasOwnProperty('y') p.hasOwnProperty('toString') // toString 是原型对象的属性 p.__proto__.hasOwnProperty('toString') 原型链 当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 proto ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( proto ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。 几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。 原型的操作： Object.getPrototypeOf() Object.setPrototypeOf() // 等价于 obj.__proto__ 继承属性 当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。 继承方法 JavaScript 并没有其他基于类的语言所定义的“方法”。在 JavaScript 里，任何函数都可以添加到对象上作为对象的属性。 4 种对象的创建方法 直接创建 var o = {name: 'Tom'} function f() { } // o 与 f 都是对象 使用构造器创建 new 后面的函数被称为构造器 constructor function Person() { this.name = 'name' } Person.prototype.sayHello = function() { console.log('say hello') } let man = new Person() class 关键字 class Person { constructor(name) { this.name = name; } } class Man extends Person { constructor(age) { super('') this.age = age } } let man = new Man() 其他 new 操作 var o = new Foo(); 实际操作是 var o = new Object() // 先创建对象实例 o.__proto__ = Foo.prototype // 设置实例的原型 Foo.call(o) // 调用 constructor hasOwnProperty 检测是否自己是否定义了属性，不在原型链查找 // 不会在原型链递归查找，只在当前实例查找 obj.hasOwnProperty('prop') propto 与 prototype propto 隐式原型 prototype 显示原型 在 js 中，万物皆对象。Funtion 也是对象，方法的原型（Funtion.prototype）也是对象。对象具有属性 proto，指向构造该对象的构造函数的原型(构造函数的 prototype )。实例可以通过 proto 调用构造函数原型链中的属性和方法。 Function 除了有 ptoto 外，还有原型属性 prototype 。prototype 是一个指针，指向一个对象。在这个对象中包含了所有实例共享的属性和方法(这个对象叫做原型对象)。原型对象也有一个属性叫 constructor，这个属性指回原构造函数。 参考：https://www.zhihu.com/question/34183746 js 中的类是如何存储的？有 metaclass 和 class 的概念吗？ 继承、覆盖、重载 是如何实现的？ 属性和方法的继承，通过原型链来实现。属性和方法会递归向上查找，直到找到。 覆盖，就是重新定义一个方法即可。查找方法时，会优先查找到子类的方法。 没有 重载 的概念 es6 中的 class 是如何实现的？ class 是构造函数的语法糖 class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return '(' + this.x + ', ' + this.y + ')'; } } typeof Point // function 是一个函数 等价于 function Point(x, y) { this.x = x; this.y = y; } Point.prototype.toString = function () { return '(' + this.x + ', ' + this.y + ')'; }; var p = new Point(1, 2); js 中对象与类的关系是？ 类中定义了所有对象共享的属性和方法，在 js 中通过函数的原型对象 (func.prototype) 来实现类的功能。 所以 一个类，实际是一个 Function 对象。类定一个属性和方法都在函数的原型对象上。Function 自身定义了类的构造函数。 类的构造方法怎么定义？内存何时回收？ 一个普通的函数，当通过 new 来创建一个实例。则该函数就是这个实例的构造方法。 实例的 proto 指向构造方法的 prototype （构造方法的原型对象）。原型对象里包含共享的属性和方法。 "},"web/es6.html":{"url":"web/es6.html","title":"ES6","keywords":"","body":"es6 async、await async 表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。 返回值 async 函数返回的 Promise 对象。await 返回的是值。 异常处理： 如果 await 的 Promise 对象 reject，则 async 函数返回的 Promise 也会 reject。异常处理类比 promise.all([p1, p2, p3])。 promise.all([]) 中的多个 promise 会并发执行，但 await 的 promise 是前后依赖的。 function testPromise () { const result = asyncMethod(); result.then(function(value) { console.log(value); }, function (error) { console.log(error); }); } async function asyncMethod () { const text1 = await asynGet1() const result = await asynGet2(text1) return result } async function asynGet1 () { const text = await new Promise(function(resolve, reject) { setTimeout(function () { resolve('text1'); // reject('reject 失败'); }, 3000); }); return text; } async function asynGet2 (text1) { const text = await new Promise(function(resolve, reject) { setTimeout(function () { resolve(text1 + ' text2'); // reject('reject 失败'); }, 3000); }); return text; } "},"web/module.html":{"url":"web/module.html","title":"Module","keywords":"","body":"模块相关 es6 的模块设计是尽量的静态化，在编译时就能确定模块的依赖关系，以及输入和输出的变量 CommonJS 只能在运行时确定模块依赖关系 ES6 中的 module moduleA.js console.log('加载 moduleA') export function sayHello(name) { console.log(\"Hello \" + name) } export var firstName = 'Jackson' moduleB.js function multiply(a, b) { return a * b } // 默认输入模块，只能设置一个 export default { multiply } import 使用 import moudleB from './moduleB.js' moudleB.multiply(10, 20) import { firstName, sayHello } from './moduleA.js'; sayHello(\"Peter\") 在浏览器中使用 es6 module node 中使用的 module CommonJS CommonJS 模块就是对象，输入时必须查找对象的属性 export module.exports.test = () => console.log('test moudle'); module.exports.firstName = 'Peter'; require const cert = require('./utils/cert.js'); cert.test() 参考 http://es6.ruanyifeng.com/#docs/module https://github.com/mqyqingfeng/Blog/issues/108 http://nodejs.cn/api/modules.html "},"android/":{"url":"android/","title":"android","keywords":"","body":"index "},"android/activity.html":{"url":"android/activity.html","title":"activity","keywords":"","body":"activity "},"other/longconnection.html":{"url":"other/longconnection.html","title":"长连方案","keywords":"","body":"长连方案 在项目中，像IM聊天、配置立刻生效等需求，要求我们需要维护一个长连通道，让 server 有能力主动给 client 发消息。 在 iOS 中，系统提供的APNS通道，本身就是一种方式。但缺点是，用户可以选择关闭，没法保证触达所有用户。 一般我们需要自己维护一个长连通道，满足上面的业务需求。通过这个通道可以双向收发消息，保证稳定、可靠、快速收发消息。 长连通道 双向。都可以 发消息、收消息 稳定。打开、关闭 通道，确保通道没有中断 可靠。发送、接收数据时，不会丢失、不会乱序、不会被篡改。重试发送 快速。发送、接收数据，尽可能快 长连通道方案： websocket 自己维护 tcp 连接 使用 mars 库维护 tcp 连接 具体需求 快 建立连接要快 发送消息要快 接收消息要快 可靠 不丢失数据，不会被截获、被篡改 对网络变化敏感，弱网环境也能尽快收发送消息 "}}